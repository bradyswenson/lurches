<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<title>Lurches — Genetic Simulation Sandbox</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a14;
    color: #b0b0c0;
    font-family: 'Menlo', 'Courier New', 'Consolas', monospace;
    font-size: 13px;
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
    user-select: none;
  }

  /* Top Bar */
  #topbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 16px;
    background: #12121e;
    border-bottom: 1px solid #2a2a3a;
    min-height: 36px;
    flex-shrink: 0;
  }
  #topbar .title { color: #e0e0f0; font-size: 16px; font-weight: bold; letter-spacing: 2px; transition: color 0.15s; }
  #topbar .title:hover { color: #aaaaff; }
  #topbar .stats { display: flex; gap: 18px; color: #8888aa; font-size: 12px; }
  #topbar .stats span { color: #ccccdd; }
  #topbar .controls { display: flex; gap: 8px; align-items: center; }
  #topbar .controls button {
    background: #1e1e2e; border: 1px solid #3a3a4a; color: #aab; padding: 3px 10px;
    font-family: inherit; font-size: 12px; cursor: pointer; border-radius: 3px;
  }
  #topbar .controls button:hover { background: #2a2a3e; border-color: #5a5a7a; }
  #topbar .controls button.active { background: #3a2a2a; border-color: #aa4444; color: #ff8888; }
  #speed-display { color: #88aa88; min-width: 30px; text-align: center; }

  /* Main Area */
  #main {
    flex: 1;
    display: flex;
    overflow: hidden;
  }

  /* Grid Canvas */
  #grid-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: #0e0e1a;
  }
  #grid-canvas {
    position: absolute;
    top: 0; left: 0;
  }
  #grid-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
  }

  /* Side Panel */
  #sidepanel {
    width: 300px;
    background: #10101c;
    border-left: 1px solid #2a2a3a;
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    overflow-y: auto;
  }
  .panel-section {
    padding: 10px 12px;
    border-bottom: 1px solid #1e1e2e;
  }
  .panel-title {
    color: #8888bb;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 6px;
  }
  .stat-row {
    display: flex;
    justify-content: space-between;
    margin: 2px 0;
    font-size: 12px;
  }
  .stat-label { color: #7777aa; }
  .stat-value { color: #ccccdd; }
  .gene-bar {
    display: flex;
    align-items: center;
    margin: 2px 0;
    font-size: 11px;
  }
  .gene-label { width: 32px; color: #7777aa; }
  .gene-track {
    flex: 1;
    height: 10px;
    background: #1a1a2a;
    margin: 0 6px;
    border-radius: 2px;
    overflow: hidden;
  }
  .gene-fill { height: 100%; border-radius: 2px; }
  .gene-val { width: 60px; text-align: right; color: #aaaacc; }
  .gene-find {
    width: 16px; height: 16px; display: inline-flex; align-items: center; justify-content: center;
    cursor: pointer; color: #555577; font-size: 10px; border-radius: 3px; margin-left: 2px;
    transition: color 0.15s, background 0.15s;
  }
  .gene-find:hover { color: #ccccee; background: #2a2a3e; }

  /* Timeline */
  #timeline-section { max-height: 200px; overflow-y: auto; }
  .timeline-toggle {
    cursor: pointer; display: flex; align-items: center; justify-content: space-between;
  }
  .timeline-toggle:hover { color: #aaaadd; }
  .tl-entry {
    display: flex; gap: 6px; padding: 2px 0; font-size: 11px; border-bottom: 1px solid #151520;
    align-items: flex-start;
  }
  .tl-round { color: #555577; min-width: 46px; text-align: right; font-size: 10px; flex-shrink: 0; }
  .tl-icon { font-size: 12px; flex-shrink: 0; }
  .tl-msg { color: #9999bb; }
  .tl-entry.godmode .tl-msg { color: #cc88cc; }
  .tl-entry.trait .tl-msg { color: #88cccc; }
  .tl-entry.milestone .tl-msg { color: #cccc66; }

  /* Bottom Bar */
  #bottombar {
    display: flex;
    flex-direction: column;
    background: #0c0c18;
    border-top: 1px solid #2a2a3a;
    max-height: 200px;
    flex-shrink: 0;
  }
  #event-log {
    flex: 1;
    padding: 6px 12px;
    overflow-y: auto;
    font-size: 11px;
    max-height: 120px;
    min-height: 60px;
  }
  .log-entry { margin: 1px 0; color: #6666aa; }
  .log-entry.birth { color: #66aa66; }
  .log-entry.death { color: #aa4444; }
  .log-entry.combat { color: #cc8844; }
  .log-entry.event { color: #cccc44; }
  .log-entry.god { color: #cc44cc; }
  .log-entry.discovery { color: #44ccaa; }

  #hotkeys {
    padding: 4px 12px;
    font-size: 11px;
    color: #555577;
    border-top: 1px solid #1a1a2a;
    white-space: nowrap;
    overflow-x: auto;
    flex-shrink: 0;
  }
  #hotkeys kbd {
    background: #1a1a2a;
    border: 1px solid #2a2a3a;
    border-radius: 2px;
    padding: 0 4px;
    color: #8888aa;
    font-family: inherit;
    font-size: 10px;
  }

  /* God Mode Overlay */
  #godmode-panel {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #14141f;
    border: 2px solid #aa44aa;
    padding: 16px 20px;
    z-index: 100;
    min-width: 420px;
    box-shadow: 0 0 40px rgba(170, 68, 170, 0.3);
  }
  #godmode-panel h2 {
    color: #dd66dd;
    font-size: 14px;
    margin-bottom: 10px;
    text-align: center;
    letter-spacing: 2px;
  }
  .gm-row { display: flex; gap: 8px; margin: 4px 0; }
  .gm-btn {
    flex: 1;
    background: #1e1e2e;
    border: 1px solid #3a3a4a;
    color: #ccaadd;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    border-radius: 3px;
    text-align: left;
  }
  .gm-btn:hover { background: #2a2a3e; border-color: #aa44aa; }
  .gm-btn kbd { color: #dd88dd; margin-right: 4px; }
  .gm-divider { border-top: 1px solid #2a2a3a; margin: 8px 0; }

  /* Confirm Modal */
  #confirm-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(5, 5, 12, 0.85);
    z-index: 400;
    align-items: center;
    justify-content: center;
  }
  #confirm-overlay.visible { display: flex; }
  #confirm-card {
    background: #10101c;
    border: 1px solid #3a3a5a;
    border-radius: 8px;
    padding: 24px 32px;
    max-width: 380px;
    text-align: center;
    box-shadow: 0 12px 60px rgba(0,0,0,0.6);
  }
  #confirm-card p {
    color: #ccccee;
    font-size: 13px;
    margin: 0 0 20px 0;
    line-height: 1.5;
  }
  #confirm-card .confirm-btns {
    display: flex;
    gap: 12px;
    justify-content: center;
  }
  #confirm-card .confirm-btns button {
    font-family: inherit;
    font-size: 12px;
    padding: 8px 24px;
    border-radius: 4px;
    cursor: pointer;
    border: 1px solid #3a3a5a;
    min-width: 90px;
  }
  #confirm-cancel {
    background: #1e1e2e;
    color: #888899;
  }
  #confirm-cancel:hover { background: #2a2a3e; border-color: #5a5a7a; }
  #confirm-ok {
    background: #2a2244;
    color: #ccaaee;
    border-color: #6a4a8a;
  }
  #confirm-ok:hover { background: #3a3260; border-color: #aa66cc; }
  #confirm-save {
    background: linear-gradient(180deg, #1e2e1e 0%, #1a2a1a 100%);
    color: #88ee88;
    border-color: #44aa44;
  }
  #confirm-save:hover { background: linear-gradient(180deg, #2a3e2a 0%, #243a24 100%); border-color: #66cc66; }
  #confirm-save:disabled { opacity: 0.35; cursor: not-allowed; }
  #seed-name-input {
    background: #14142a;
    border: 1px solid #2a2a44;
    color: #ccccdd;
    padding: 6px 10px;
    font-family: inherit;
    font-size: 12px;
    width: 100%;
    border-radius: 3px;
    outline: none;
    margin-top: 10px;
    transition: border-color 0.2s;
  }
  #seed-name-input:focus { border-color: #44aa44; }
  #confirm-seed-display {
    color: #555577;
    font-size: 11px;
    font-family: monospace;
    margin-top: 8px;
  }
  /* Saved seeds on setup screen */
  .saved-seeds-list {
    max-height: 120px;
    overflow-y: auto;
    margin-top: 6px;
  }
  .saved-seed-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 5px 8px;
    background: #14142a;
    border: 1px solid #2a2a44;
    border-radius: 3px;
    margin-bottom: 4px;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
  }
  .saved-seed-item:hover { border-color: #5555aa; background: #1a1a30; }
  .saved-seed-name {
    color: #ccccdd;
    font-size: 12px;
    flex: 1;
  }
  .saved-seed-meta {
    color: #555577;
    font-size: 10px;
    font-family: monospace;
    margin-left: 8px;
  }
  .saved-seed-delete {
    color: #554444;
    font-size: 11px;
    margin-left: 8px;
    cursor: pointer;
    padding: 0 4px;
    transition: color 0.2s;
  }
  .saved-seed-delete:hover { color: #ff4444; }

  /* Setup Screen */
  #setup-screen {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: #0a0a14;
    z-index: 200;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
  }
  .setup-card {
    background: #10101c;
    border: 1px solid #2a2a3a;
    border-radius: 8px;
    padding: 32px 36px 28px;
    width: 420px;
    box-shadow: 0 8px 40px rgba(0,0,0,0.5);
  }
  .setup-header {
    text-align: center;
    margin-bottom: 24px;
    padding-bottom: 16px;
    border-bottom: 1px solid #1e1e2e;
  }
  .setup-header h1 {
    color: #ccccee;
    font-size: 28px;
    letter-spacing: 8px;
    margin-bottom: 6px;
  }
  .setup-header .subtitle {
    color: #555577;
    font-size: 15px;
    font-style: italic;
    max-width: 320px;
    margin: 0 auto;
    line-height: 1.4;
  }
  .setup-header .ascii-art {
    color: #333355;
    font-size: 10px;
    line-height: 1.1;
    margin-top: 10px;
    letter-spacing: 1px;
  }
  .setup-group {
    margin-bottom: 14px;
  }
  .setup-group-title {
    color: #666688;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    margin-bottom: 8px;
  }
  .setup-row { display: flex; gap: 10px; }
  .setup-field { flex: 1; margin-bottom: 10px; }
  .setup-field label {
    display: block;
    color: #7777aa;
    font-size: 11px;
    margin-bottom: 3px;
  }
  .setup-field select, .setup-field input {
    background: #14142a;
    border: 1px solid #2a2a44;
    color: #ccccdd;
    padding: 5px 8px;
    font-family: inherit;
    font-size: 12px;
    width: 100%;
    border-radius: 3px;
    outline: none;
    transition: border-color 0.2s;
  }
  .setup-field select:focus, .setup-field input:focus {
    border-color: #5555aa;
  }
  .setup-field select { cursor: pointer; }
  #start-btn {
    display: block;
    width: 100%;
    margin-top: 6px;
    background: linear-gradient(180deg, #1e2e1e 0%, #1a2a1a 100%);
    border: 1px solid #44aa44;
    color: #88ee88;
    padding: 10px 0;
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    letter-spacing: 3px;
    border-radius: 4px;
    transition: all 0.2s;
  }
  #start-btn:hover { background: linear-gradient(180deg, #2a3e2a 0%, #243a24 100%); box-shadow: 0 0 16px rgba(68,170,68,0.2); }
  .github-link:hover { color: #8888aa !important; }

  /* Population Sparkline */
  #sparkline-canvas {
    width: 100%;
    height: 40px;
  }

  /* Selection highlight */
  .selected-highlight {
    position: absolute;
    border: 2px solid #ffff44;
    pointer-events: none;
    box-shadow: 0 0 8px rgba(255,255,68,0.4);
    z-index: 50;
  }

  /* Help Popover */
  #help-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(5, 5, 12, 0.85);
    z-index: 300;
    align-items: center;
    justify-content: center;
  }
  #help-overlay.visible { display: flex; }
  #help-card {
    background: #10101c;
    border: 1px solid #3a3a5a;
    border-radius: 8px;
    width: 660px;
    height: 75vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 12px 60px rgba(0,0,0,0.6);
  }
  #help-card .help-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    border-bottom: 1px solid #1e1e2e;
  }
  #help-card .help-header h2 { color: #ccccee; font-size: 14px; letter-spacing: 2px; }
  #help-close {
    background: none; border: none; color: #666688; cursor: pointer;
    font-family: inherit; font-size: 16px; padding: 2px 6px;
  }
  #help-close:hover { color: #aaaacc; }
  .help-tabs {
    display: flex;
    border-bottom: 1px solid #1e1e2e;
    padding: 0 8px;
  }
  .help-tab {
    background: none;
    border: none;
    border-bottom: 2px solid transparent;
    color: #666688;
    padding: 8px 14px;
    font-family: inherit;
    font-size: 11px;
    cursor: pointer;
    letter-spacing: 0.5px;
    transition: all 0.15s;
  }
  .help-tab:hover { color: #aaaacc; }
  .help-tab.active {
    color: #ccccee;
    border-bottom-color: #6666aa;
  }
  .help-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px 20px;
    font-size: 12px;
    line-height: 1.6;
    color: #9999bb;
  }
  .help-body h3 { color: #aaaacc; font-size: 13px; margin: 12px 0 6px; }
  .help-body h3:first-child { margin-top: 0; }
  .help-body p { margin: 4px 0 8px; }
  .help-body table { width: 100%; border-collapse: collapse; margin: 6px 0 10px; }
  .help-body th { text-align: left; color: #8888aa; font-size: 11px; padding: 3px 6px; border-bottom: 1px solid #1e1e2e; }
  .help-body td { padding: 3px 6px; border-bottom: 1px solid #14141e; }
  .help-body code { background: #1a1a2e; padding: 1px 4px; border-radius: 2px; color: #aaccaa; }
  .help-body .chip {
    display: inline-block; padding: 1px 6px; border-radius: 3px; font-size: 10px;
    background: #1a1a2e; margin-right: 4px;
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: #0a0a14; }
  ::-webkit-scrollbar-thumb { background: #2a2a3a; border-radius: 3px; }

  /* Mobile notice */
  #mobile-notice {
    display: none;
    background: #1a1a2e;
    border: 1px solid #3a3a5a;
    border-radius: 8px;
    padding: 24px 28px;
    margin: 20px;
    max-width: 340px;
    text-align: center;
    color: #8888aa;
    font-size: 14px;
    line-height: 1.6;
  }
  #mobile-notice h2 { color: #ccccee; font-size: 18px; margin: 0 0 12px 0; letter-spacing: 2px; }
  #mobile-notice .ascii-lurches { color: #555577; font-family: monospace; font-size: 12px; margin: 14px 0; }
  #mobile-notice a { color: #4488ff; text-decoration: none; }
  @media (max-width: 768px) {
    #mobile-notice { display: block; }
    .setup-card { display: none; }
  }
</style>
</head>
<body>

<!-- ═══════════════════════════════════════ -->
<!-- SETUP SCREEN                           -->
<!-- ═══════════════════════════════════════ -->
<div id="setup-screen">
  <div id="mobile-notice">
    <h2>LURCHES</h2>
    <div style="color:#8888aa; font-size:12px; margin-bottom:8px; letter-spacing:1px;">A genetic simulation sandbox<br>with an ASCII attitude</div>
    <div class="ascii-lurches">~..##^^..<span style="color:#ff4444">@</span>.##^^""^^##...<span style="color:#44ff44">@</span>..~</div>
    <p>Lurches is the rebirth of a 1992 terminal game and best experienced on a laptop or desktop — the simulation needs a keyboard and a wider screen to really come alive.</p>
    <p style="color:#666688; font-size:12px; margin-top:16px;">Bookmark <a href="https://lurches.net">lurches.net</a> and come back on a bigger screen. Your lurches await.</p>
  </div>
  <div class="setup-card">
    <div class="setup-header">
      <h1>LURCHES</h1>
      <div class="subtitle">A genetic simulation sandbox<br>with an ASCII attitude</div>
      <div class="ascii-art">
~..##^^..~..<span style="color:#ff4444">@</span>.##^^""^^##...<span style="color:#44ff44">@</span>..~<br>
..##<span style="color:#4488ff">@</span>^""^^##....##^^""<span style="color:#ffff44">@</span>^##...<br>
~..##^^..<span style="color:#ff44ff">@</span>~~..##^^""^^##<span style="color:#44ffff">@</span>.~
      </div>
    </div>

    <div class="setup-group">
      <div class="setup-group-title">World</div>
      <div class="setup-row">
        <div class="setup-field">
          <label>Map</label>
          <select id="map-preset">
            <option value="random" selected>Random</option>
            <option value="pangaea">Pangaea</option>
            <option value="eden">Eden</option>
            <option value="crucible">The Crucible</option>
            <option value="archipelago">Archipelago</option>
            <option value="ringworld">Ring World</option>
            <option value="waterworld">Waterworld</option>
          </select>
        </div>
        <div class="setup-field">
          <label>Width</label>
          <input type="number" id="grid-w" value="80" min="20" max="200">
        </div>
        <div class="setup-field">
          <label>Height</label>
          <input type="number" id="grid-h" value="40" min="20" max="100">
        </div>
      </div>
    </div>

    <div class="setup-group">
      <div class="setup-group-title">Population</div>
      <div class="setup-row">
        <div class="setup-field">
          <label>Species</label>
          <select id="lurch-preset">
            <option value="balanced">Balanced</option>
            <option value="warriors">Warriors</option>
            <option value="thinkers">Thinkers</option>
            <option value="survivors">Survivors</option>
            <option value="chaos">Chaos</option>
            <option value="specialists">Specialists</option>
          </select>
        </div>
        <div class="setup-field">
          <label>Count</label>
          <input type="number" id="pop-count" value="200" min="4" max="400">
        </div>
        <div class="setup-field">
          <label>Mutation</label>
          <input type="number" id="mutation-rate" value="0.05" min="0.01" max="0.2" step="0.01">
        </div>
      </div>
      <div class="setup-row">
        <div class="setup-field" style="flex:1;">
          <label>Birth Rate: <span id="birth-rate-val">1.0x</span></label>
          <input type="range" id="birth-rate" value="1.6" min="0.4" max="2.8" step="0.2" style="width:100%;">
        </div>
      </div>
    </div>

    <div class="setup-group">
      <div class="setup-group-title">Seed</div>
      <div class="setup-field" style="margin-bottom:0;">
        <input type="text" id="rng-seed" value="" placeholder="Leave blank for random seed, or type a word / number">
      </div>
    </div>

    <div class="setup-group" id="saved-seeds-group" style="display:none;">
      <div class="setup-group-title">Saved Seeds</div>
      <div class="saved-seeds-list" id="saved-seeds-list"></div>
    </div>

    <button id="start-btn">BEGIN SIMULATION</button>
    <a href="https://github.com/bradyswenson/lurches" target="_blank" rel="noopener" class="github-link" style="display:block;margin-top:12px;text-align:center;color:#555577;transition:color 0.2s;" title="View on GitHub">
      <svg width="24" height="24" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>
    </a>
  </div>
</div>

<!-- ═══════════════════════════════════════ -->
<!-- GAME UI                                -->
<!-- ═══════════════════════════════════════ -->
<div id="topbar">
  <div class="title" id="title-btn" style="cursor:pointer;" title="Back to home">LURCHES</div>
  <div class="stats">
    Day: <span id="round-num">0</span> &nbsp;│&nbsp;
    Pop: <span id="pop-num">0</span> &nbsp;│&nbsp;
    Births: <span id="birth-num">0</span> &nbsp;│&nbsp;
    Deaths: <span id="death-num">0</span> &nbsp;│&nbsp;
    Avg Age: <span id="avg-age">0</span> &nbsp;│&nbsp;
    Food: <span id="food-pct">0%</span>
  </div>
  <div class="controls">
    <button id="pause-btn" title="Space">⏸ Pause</button>
    <button id="speed-down" title="-">−</button>
    <span id="speed-display">1x</span>
    <button id="speed-up" title="+">+</button>
    <button id="god-btn" title="G">⚡ God</button>
    <button id="help-btn" title="?">? Help</button>
  </div>
</div>

<div id="main">
  <div id="grid-container">
    <canvas id="grid-canvas"></canvas>
    <div id="grid-overlay"></div>
    <div id="god-tool-status" style="display:none;position:absolute;top:8px;left:50%;transform:translateX(-50%);background:rgba(20,20,32,0.9);border:1px solid #aa44aa;padding:6px 16px;border-radius:4px;color:#dd88dd;font-size:12px;z-index:90;pointer-events:none;letter-spacing:1px;"></div>
    <div id="godmode-panel">
      <h2>⚡ GOD MODE ⚡</h2>
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;padding:6px 8px;background:#1a1a28;border-radius:4px;">
        <span style="color:#8888aa;font-size:11px;white-space:nowrap;">Severity</span>
        <input type="range" id="god-severity" min="1" max="10" value="5" style="flex:1;accent-color:#aa44aa;height:4px;">
        <span id="god-severity-val" style="color:#dd88dd;font-size:13px;min-width:22px;text-align:center;font-weight:bold;">5</span>
      </div>
      <div class="panel-title">Environmental Events</div>
      <div class="gm-row">
        <button class="gm-btn" data-event="drought"><kbd>1</kbd> Drought</button>
        <button class="gm-btn" data-event="flood"><kbd>2</kbd> Flood</button>
      </div>
      <div class="gm-row">
        <button class="gm-btn" data-event="wildfire"><kbd>3</kbd> Wildfire</button>
        <button class="gm-btn" data-event="earthquake"><kbd>4</kbd> Earthquake</button>
      </div>
      <div class="gm-row">
        <button class="gm-btn" data-event="iceage"><kbd>5</kbd> Ice Age</button>
        <button class="gm-btn" data-event="meteor"><kbd>6</kbd> Meteor</button>
      </div>
      <div class="gm-row">
        <button class="gm-btn" data-event="fertile"><kbd>9</kbd> Fertile Season</button>
      </div>
      <div class="gm-divider"></div>
      <div class="panel-title">Biological Events</div>
      <div class="gm-row">
        <button class="gm-btn" data-event="plague"><kbd>7</kbd> Plague</button>
        <button class="gm-btn" data-event="mutationburst"><kbd>8</kbd> Mutation Burst</button>
      </div>
      <div class="gm-row">
        <button class="gm-btn" data-event="bottleneck"><kbd>C</kbd> Cull (kill 50%)</button>
        <button class="gm-btn" data-event="rejuvenation"><kbd>R</kbd> Rejuvenation</button>
      </div>
      <div class="gm-divider"></div>
      <div class="panel-title">Direct — click or drag on grid</div>
      <div class="gm-row">
        <button class="gm-btn" data-tool="smite"><kbd>L</kbd> Smite ⚡</button>
        <button class="gm-btn" data-tool="bless"><kbd>V</kbd> Bless ✨</button>
      </div>
      <div class="gm-row">
        <button class="gm-btn" data-tool="spawn"><kbd>S</kbd> Spawn</button>
        <button class="gm-btn" data-tool="food"><kbd>P</kbd> Place Food</button>
        <button class="gm-btn" data-tool="wall"><kbd>W</kbd> Build Wall</button>
      </div>
      <div style="margin-top:10px;text-align:center;color:#666688;font-size:11px;">
        Press <kbd>G</kbd> or <kbd>ESC</kbd> to close
      </div>
    </div>
  </div>

  <div id="sidepanel">
    <div class="panel-section" id="terrain-panel">
      <div class="panel-title">Terrain</div>
      <div id="terrain-content" style="color:#555577;font-size:12px;">
        Click any cell to inspect
      </div>
    </div>
    <div class="panel-section" id="inspector-panel">
      <div class="panel-title">Lurch Inspector</div>
      <div id="inspector-content" style="color:#555577;font-size:12px;">
        Click a Lurch on the grid to inspect
      </div>
    </div>
    <div class="panel-section">
      <div class="panel-title">Population</div>
      <canvas id="sparkline-canvas" height="40"></canvas>
    </div>
    <div class="panel-section">
      <div class="panel-title">Dominant Traits</div>
      <div id="trait-distribution"></div>
    </div>
    <div class="panel-section">
      <div class="panel-title">Active Events</div>
      <div id="active-events" style="color:#555577;font-size:12px;">None</div>
    </div>
    <div class="panel-section" id="timeline-section">
      <div class="panel-title timeline-toggle" id="timeline-toggle">Timeline <span style="font-size:10px;">▼</span></div>
      <div id="timeline-content"></div>
    </div>
  </div>
</div>

<div id="bottombar">
  <div id="event-log"></div>
  <div id="hotkeys">
    <kbd>Space</kbd> Pause &nbsp;
    <kbd>+/-</kbd> Speed &nbsp;
    <kbd>G</kbd> God Mode &nbsp;
    <kbd>N</kbd> Step &nbsp;
    <kbd>F</kbd> Follow &nbsp;
    <kbd>Click</kbd> Inspect &nbsp;
    <kbd>Arrow Keys</kbd> Scroll &nbsp;
    <kbd>?</kbd> Help
  </div>
</div>

<!-- Confirm / Seed Save Modal -->
<div id="confirm-overlay">
  <div id="confirm-card">
    <p>Save this seed before leaving?<br><span style="color:#777788;font-size:12px;">Name it to replay this world later.</span></p>
    <div id="confirm-seed-display"></div>
    <input type="text" id="seed-name-input" placeholder="Name this seed..." maxlength="30" autocomplete="off">
    <div class="confirm-btns" style="margin-top:16px;">
      <button id="confirm-cancel">Cancel</button>
      <button id="confirm-ok">Exit</button>
      <button id="confirm-save" disabled>Save &amp; Exit</button>
    </div>
  </div>
</div>

<!-- ═══════════════════════════════════════ -->
<!-- HELP OVERLAY                           -->
<!-- ═══════════════════════════════════════ -->
<div id="help-overlay">
  <div id="help-card">
    <div class="help-header">
      <h2>LURCHES — GUIDE</h2>
      <button id="help-close">✕</button>
    </div>
    <div class="help-tabs">
      <button class="help-tab active" data-tab="overview">Overview</button>
      <button class="help-tab" data-tab="terrain">Terrain</button>
      <button class="help-tab" data-tab="lurches">Lurches</button>
      <button class="help-tab" data-tab="genetics">Genetics</button>
      <button class="help-tab" data-tab="ai">Intelligence</button>
      <button class="help-tab" data-tab="godmode">God Mode</button>
      <button class="help-tab" data-tab="controls">Controls</button>
    </div>
    <div class="help-body" id="help-body">
      <!-- Populated by JS -->
    </div>
  </div>
</div>

<!-- ═══════════════════════════════════════ -->
<!-- GAME ENGINE                            -->
<!-- ═══════════════════════════════════════ -->
<script>
// ============================================================
// SEEDED RNG (mulberry32)
// ============================================================
class SeededRNG {
  constructor(seed) {
    this.seed = seed | 0;
    this.state = seed | 0;
  }
  next() {
    let t = this.state += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
  // 0 to max-1
  nextInt(max) { return Math.floor(this.next() * max); }
  // min to max inclusive
  range(min, max) { return min + this.next() * (max - min); }
  // Normal distribution (Box-Muller)
  gaussian(mean = 0, std = 1) {
    const u1 = this.next();
    const u2 = this.next();
    return mean + std * Math.sqrt(-2 * Math.log(u1 || 0.0001)) * Math.cos(2 * Math.PI * u2);
  }
  // Pick from array
  pick(arr) { return arr[this.nextInt(arr.length)]; }
  // Shuffle array in place
  shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = this.nextInt(i + 1);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
}

// ============================================================
// TERRAIN DEFINITIONS
// ============================================================
const TERRAIN = {
  DEEP_WATER:  { id: 0, char: '~', name: 'Deep Water', foodRegen: 3, moveCost: 4, safety: 2, visibility: 5, color: '#2255aa', bgColor: '#0a1a33', drowning: true },
  PLAINS:      { id: 1, char: '.', name: 'Plains',     foodRegen: 2, moveCost: 1, safety: 2, visibility: 5, color: '#7a8a5a', bgColor: '#1a1e14' },
  FOREST:      { id: 2, char: '#', name: 'Forest',     foodRegen: 4, moveCost: 2, safety: 4, visibility: 2, color: '#3a7a3a', bgColor: '#0e1e0e' },
  MOUNTAIN:    { id: 3, char: '^', name: 'Mountain',   foodRegen: 1, moveCost: 4, safety: 5, visibility: 5, color: '#8a8a8a', bgColor: '#1e1e1e' },
  SWAMP:       { id: 4, char: '"', name: 'Swamp',      foodRegen: 3, moveCost: 3, safety: 1, visibility: 2, color: '#5a7a3a', bgColor: '#141e0e', disease: true },
  DESERT:      { id: 5, char: '░', name: 'Desert',     foodRegen: 0, moveCost: 2, safety: 3, visibility: 5, color: '#ba8a3a', bgColor: '#1e1608' },
  SHALLOWS:    { id: 6, char: '≈', name: 'Shallows',   foodRegen: 2, moveCost: 2, safety: 3, visibility: 5, color: '#4a99aa', bgColor: '#0e1a20' },
  RUINS:       { id: 7, char: '♠', name: 'Ruins',      foodRegen: 0, moveCost: 1, safety: 2, visibility: 2, color: '#7a5a8a', bgColor: '#14101a' },
  WALL:        { id: 8, char: '█', name: 'Wall',       foodRegen: 0, moveCost: 99, safety: 10, visibility: 0, color: '#555555', bgColor: '#222222', impassable: true },
  FERTILE_PLAINS: { id: 9,  char: '∞', name: 'Fertile Plains', foodRegen: 5, moveCost: 1, safety: 3, visibility: 5, color: '#ccaa33', bgColor: '#2a2210', enhanced: true },
  LUSH_FOREST:   { id: 10, char: '♣', name: 'Lush Forest',   foodRegen: 6, moveCost: 2, safety: 5, visibility: 2, color: '#22cc44', bgColor: '#0a2a0e', enhanced: true, shelter: true },
};
const TERRAIN_BY_ID = Object.values(TERRAIN);
const TERRAIN_IDS = Object.keys(TERRAIN);

// ============================================================
// GENE DEFINITIONS
// ============================================================
const GENES = ['vitality','speed','strength','intelligence','adaptability','perception','size'];
const GENE_COLORS = {
  vitality:     '#44ff44',
  speed:        '#44ffff',
  strength:     '#ff4444',
  intelligence: '#4488ff',
  adaptability: '#ffff44',
  perception:   '#cccccc',
  size:         '#ffffff',
};
const GENE_SHORT = { vitality:'VIT', speed:'SPD', strength:'STR', intelligence:'INT', adaptability:'ADP', perception:'PER', size:'SIZ' };

// ============================================================
// CONFIG
// ============================================================
const CONFIG = {
  gridW: 80,
  gridH: 40,
  population: 60,
  mutationRate: 0.05,
  birthRate: 0.5,
  macroMutationChance: 0.02,
  foodCap: 10,
  baseFoodStart: 5,
  hungerPerRound: 1.5,
  energyPerRound: -0.5,
  sleepEnergyGain: 15,
  eatHungerReduce: 25,
  fightEnergyCost: 28,
  reproduceEnergyCost: 20,
  hideEnergyCost: 2,
  juvenileDuration: 10,
  starvationThreshold: 100,
  diseaseChance: 0.05,
  diseaseDamage: 8,
  drownChance: 0.3,
  desertEnergyDrain: 5,
  kinSimilarityThreshold: 0.7,
  maxLifespan: 200,
  baseLifespan: 80,
  speedLevels: [500, 250, 100, 50, 20],
  speedLabels: ['1x', '2x', '5x', '10x', 'Max'],
};

// ============================================================
// LURCH ID COUNTER
// ============================================================
let nextLurchId = 1;

// ============================================================
// WORLD
// ============================================================
class World {
  constructor(w, h, rng) {
    this.w = w;
    this.h = h;
    this.rng = rng;
    this.terrain = new Array(w * h);
    this.food = new Float32Array(w * h);
    this.lurches = [];
    this.lurchGrid = new Array(w * h).fill(null); // quick lookup: cell → lurch
  }

  idx(x, y) { return this.wrapY(y) * this.w + this.wrapX(x); }
  wrapX(x) { return ((x % this.w) + this.w) % this.w; }
  wrapY(y) { return ((y % this.h) + this.h) % this.h; }
  wrap(x, y) { return [this.wrapX(x), this.wrapY(y)]; }

  getTerrain(x, y) { return this.terrain[this.idx(x, y)]; }
  setTerrain(x, y, t) { this.terrain[this.idx(x, y)] = t; }
  getFood(x, y) { return this.food[this.idx(x, y)]; }
  setFood(x, y, v) { this.food[this.idx(x, y)] = Math.max(0, Math.min(CONFIG.foodCap, v)); }
  getLurch(x, y) { return this.lurchGrid[this.idx(x, y)]; }

  placeLurch(lurch) {
    const i = this.idx(lurch.x, lurch.y);
    this.lurchGrid[i] = lurch;
  }
  removeLurch(lurch) {
    const i = this.idx(lurch.x, lurch.y);
    if (this.lurchGrid[i] === lurch) this.lurchGrid[i] = null;
  }
  moveLurch(lurch, nx, ny) {
    this.removeLurch(lurch);
    lurch.x = this.wrapX(nx);
    lurch.y = this.wrapY(ny);
    this.placeLurch(lurch);
  }

  // Toroidal distance
  dist(x1, y1, x2, y2) {
    const dx = Math.min(Math.abs(x1 - x2), this.w - Math.abs(x1 - x2));
    const dy = Math.min(Math.abs(y1 - y2), this.h - Math.abs(y1 - y2));
    return Math.sqrt(dx * dx + dy * dy);
  }
  chebyshev(x1, y1, x2, y2) {
    const dx = Math.min(Math.abs(x1 - x2), this.w - Math.abs(x1 - x2));
    const dy = Math.min(Math.abs(y1 - y2), this.h - Math.abs(y1 - y2));
    return Math.max(dx, dy);
  }

  // Get neighbors (8-directional), wrapped
  neighbors8(x, y) {
    const n = [];
    for (let dy = -1; dy <= 1; dy++)
      for (let dx = -1; dx <= 1; dx++)
        if (dx !== 0 || dy !== 0)
          n.push([this.wrapX(x + dx), this.wrapY(y + dy)]);
    return n;
  }

  // Find empty adjacent cell
  emptyAdjacent(x, y) {
    const cells = this.rng.shuffle(this.neighbors8(x, y));
    for (const [cx, cy] of cells) {
      const t = this.getTerrain(cx, cy);
      if (!t.impassable && !this.getLurch(cx, cy)) return [cx, cy];
    }
    return null;
  }

  // Regenerate food — cooperator clusters boost regrowth (farming)
  // All lurches contribute small density bonus; cooperators contribute much more
  regenFood(foodMultiplier = 1) {
    // Pre-compute cultivation map: cooperator farming + general density bonus
    const coopMap = new Float32Array(this.w * this.h);
    for (const l of this.lurches) {
      if (!l.alive) continue;
      const cs = (l.genome.intelligence + l.genome.perception) / 2
               - (l.genome.strength + l.genome.size) / 4;
      // All lurches contribute a small density bonus to nearby food (trampled soil, scattered seeds)
      // Cooperators contribute significantly more (intentional farming)
      // Academy bonus: think tank members farm even better — organized agriculture
      const academyMult = l.thinkTank > 0 ? 1 + l.thinkTank * 4 : 1; // +20% to +60% from think tank
      const contribution = cs > 0.2 ? cs * 0.15 * academyMult : 0.03;
      const range = cs > 0.2 ? (l.thinkTank > 0 ? 3 : 2) : 1; // academy farms even wider
      for (let dy = -range; dy <= range; dy++) {
        for (let dx = -range; dx <= range; dx++) {
          const nx = this.wrapX(l.x + dx);
          const ny = this.wrapY(l.y + dy);
          coopMap[ny * this.w + nx] += contribution;
        }
      }
    }

    for (let i = 0; i < this.w * this.h; i++) {
      const t = this.terrain[i];
      const cap = t.enhanced ? CONFIG.foodCap * 1.5 : CONFIG.foodCap;
      if (this.food[i] < cap) {
        const cultivation = Math.min(coopMap[i], 2); // cap cultivation bonus at 2x
        this.food[i] = Math.min(cap, this.food[i] + t.foodRegen * 0.35 * foodMultiplier * (1 + cultivation));
      }
    }
  }

  // Cells in radius (toroidal)
  cellsInRadius(cx, cy, r) {
    const cells = [];
    const ri = Math.ceil(r);
    for (let dy = -ri; dy <= ri; dy++) {
      for (let dx = -ri; dx <= ri; dx++) {
        if (dx * dx + dy * dy <= r * r) {
          cells.push([this.wrapX(cx + dx), this.wrapY(cy + dy)]);
        }
      }
    }
    return cells;
  }
}

// ============================================================
// MAP GENERATION
// ============================================================
function generateMap(world, preset, rng) {
  const { w, h } = world;

  // Simple value noise for organic shapes
  function noise2D(x, y, freq) {
    // Hash-based noise
    const ix = Math.floor(x * freq);
    const iy = Math.floor(y * freq);
    const fx = x * freq - ix;
    const fy = y * freq - iy;
    const hash = (a, b) => {
      let h = a * 374761393 + b * 668265263 + rng.seed;
      h = (h ^ (h >> 13)) * 1274126177;
      return ((h ^ (h >> 16)) >>> 0) / 4294967296;
    };
    const v00 = hash(ix, iy);
    const v10 = hash(ix+1, iy);
    const v01 = hash(ix, iy+1);
    const v11 = hash(ix+1, iy+1);
    const sx = fx * fx * (3 - 2 * fx);
    const sy = fy * fy * (3 - 2 * fy);
    return (v00*(1-sx)*(1-sy) + v10*sx*(1-sy) + v01*(1-sx)*sy + v11*sx*sy);
  }

  function multiNoise(x, y) {
    return noise2D(x, y, 0.05) * 0.5 + noise2D(x, y, 0.12) * 0.3 + noise2D(x, y, 0.25) * 0.2;
  }

  // Presets
  const presets = {
    random() {
      // First pass: collect noise values
      const values = new Float32Array(w * h);
      let minV = Infinity, maxV = -Infinity;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const v = multiNoise(x, y);
          values[y * w + x] = v;
          if (v < minV) minV = v;
          if (v > maxV) maxV = v;
        }
      }
      // Normalize to 0-1 so terrain distribution is consistent across all seeds
      const range = maxV - minV || 1;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const v = (values[y * w + x] - minV) / range;
          let t;
          if (v < 0.12) t = TERRAIN.DEEP_WATER;
          else if (v < 0.20) t = TERRAIN.SHALLOWS;
          else if (v < 0.40) t = TERRAIN.PLAINS;
          else if (v < 0.62) t = TERRAIN.FOREST;
          else if (v < 0.72) t = TERRAIN.SWAMP;
          else if (v < 0.80) t = TERRAIN.MOUNTAIN;
          else if (v < 0.90) t = TERRAIN.DESERT;
          else t = TERRAIN.RUINS;
          world.setTerrain(x, y, t);
        }
      }
    },
    pangaea() {
      const cx = w / 2, cy = h / 2;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const d = world.dist(x, y, cx, cy) / Math.min(w, h);
          const v = multiNoise(x, y) - d * 1.2;
          let t;
          if (v < -0.15) t = TERRAIN.DEEP_WATER;
          else if (v < -0.05) t = TERRAIN.SHALLOWS;
          else if (v < 0.15) t = TERRAIN.PLAINS;
          else if (v < 0.28) t = TERRAIN.FOREST;
          else if (v < 0.35) t = TERRAIN.SWAMP;
          else if (v < 0.42) t = TERRAIN.MOUNTAIN;
          else if (v < 0.48) t = TERRAIN.DESERT;
          else t = TERRAIN.RUINS;
          world.setTerrain(x, y, t);
        }
      }
    },
    eden() {
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const v = multiNoise(x, y);
          let t;
          if (v < 0.08) t = TERRAIN.SHALLOWS;
          else if (v < 0.5) t = TERRAIN.FOREST;
          else if (v < 0.8) t = TERRAIN.PLAINS;
          else t = TERRAIN.SWAMP;
          world.setTerrain(x, y, t);
        }
      }
    },
    crucible() {
      const cx = w / 2, cy = h / 2;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const d = world.dist(x, y, cx, cy);
          if (d < 5) {
            world.setTerrain(x, y, rng.next() < 0.6 ? TERRAIN.FOREST : TERRAIN.PLAINS);
          } else if (d < 8) {
            world.setTerrain(x, y, rng.next() < 0.3 ? TERRAIN.PLAINS : TERRAIN.DESERT);
          } else {
            world.setTerrain(x, y, TERRAIN.DESERT);
          }
        }
      }
    },
    archipelago() {
      // Scatter islands
      const islands = [];
      for (let i = 0; i < 8 + rng.nextInt(6); i++) {
        islands.push({ x: rng.nextInt(w), y: rng.nextInt(h), r: 3 + rng.nextInt(6) });
      }
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          let minD = Infinity;
          for (const isl of islands) {
            minD = Math.min(minD, world.dist(x, y, isl.x, isl.y) - isl.r);
          }
          const v = noise2D(x, y, 0.15) * 3;
          const elevation = -minD + v;
          let t;
          if (elevation < -3) t = TERRAIN.DEEP_WATER;
          else if (elevation < 0) t = TERRAIN.SHALLOWS;
          else if (elevation < 2) t = TERRAIN.PLAINS;
          else if (elevation < 4) t = TERRAIN.FOREST;
          else t = TERRAIN.MOUNTAIN;
          world.setTerrain(x, y, t);
        }
      }
    },
    ringworld() {
      const cx = w / 2, cy = h / 2;
      const innerR = Math.min(w, h) * 0.15;
      const outerR = Math.min(w, h) * 0.45;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const d = world.dist(x, y, cx, cy);
          const v = noise2D(x, y, 0.12);
          if (d < innerR) {
            world.setTerrain(x, y, rng.next() < 0.3 ? TERRAIN.DEEP_WATER : TERRAIN.DESERT);
          } else if (d < innerR + 3) {
            world.setTerrain(x, y, TERRAIN.MOUNTAIN);
          } else if (d < outerR) {
            const band = (d - innerR) / (outerR - innerR);
            if (v < 0.3) world.setTerrain(x, y, TERRAIN.FOREST);
            else if (v < 0.5) world.setTerrain(x, y, TERRAIN.PLAINS);
            else if (v < 0.65) world.setTerrain(x, y, TERRAIN.SWAMP);
            else world.setTerrain(x, y, TERRAIN.RUINS);
          } else {
            world.setTerrain(x, y, TERRAIN.DEEP_WATER);
          }
        }
      }
    },
    waterworld() {
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const v = multiNoise(x, y);
          let t;
          if (v < 0.55) t = TERRAIN.DEEP_WATER;
          else if (v < 0.65) t = TERRAIN.SHALLOWS;
          else if (v < 0.75) t = TERRAIN.PLAINS;
          else if (v < 0.85) t = TERRAIN.FOREST;
          else t = TERRAIN.MOUNTAIN;
          world.setTerrain(x, y, t);
        }
      }
    }
  };

  (presets[preset] || presets.random)();

  // Initialize food
  for (let i = 0; i < w * h; i++) {
    world.food[i] = Math.min(CONFIG.foodCap, world.terrain[i].foodRegen * 1.5 + rng.next() * 2);
  }
}

// ============================================================
// LURCH MODEL
// ============================================================
class Lurch {
  constructor(id, x, y, genome, parentA = null, parentB = null) {
    this.id = id;
    this.x = x;
    this.y = y;
    this.genome = genome; // { vitality, speed, strength, intelligence, adaptability, perception, size }
    this.parentA = parentA;
    this.parentB = parentB;
    this.children = [];

    // Derived stats
    const specPen = 1 - genome.adaptability * 0.15;
    this.maxHP = 50 + genome.size * specPen * 60 + genome.vitality * 15; // SIZ primary, VIT minor toughness
    this.hp = this.maxHP;
    this.hunger = 20;
    this.energy = 80;
    this.stress = 0;
    this.age = 0;
    // Lifespan: flat base + genome-derived variance, not VIT-driven
    // Use genome hash for deterministic but varied lifespans
    const lifeVar = ((genome.speed * 7 + genome.strength * 11 + genome.intelligence * 13 + genome.perception * 17 + genome.size * 19 + genome.adaptability * 23) % 1);
    this.maxAge = CONFIG.baseLifespan + lifeVar * CONFIG.maxLifespan * 0.5;
    this.juvenile = true;
    this.juvenileTimer = CONFIG.juvenileDuration;
    this.alive = true;
    this.causeOfDeath = null;
    this.reproCooldown = 0; // Rounds until can breed again
    this.combatCooldown = 0; // Rounds of exhaustion after a kill

    // State
    this.lastAction = 'none';
    this.diseased = false;
    this.diseaseTurns = 0;
    this.warned = false; // kin warning flag
    this.hidden = false;
    this.sleeping = false;

    // Track birth round
    this.birthRound = 0;

    // Visual
    this.dominantGene = this.getDominantGene();
  }

  getDominantGene() {
    let best = GENES[0], bestVal = this.genome[GENES[0]];
    for (const g of GENES) {
      if (this.genome[g] > bestVal) { best = g; bestVal = this.genome[g]; }
    }
    return best;
  }

  get color() { return GENE_COLORS[this.dominantGene]; }

  get healthState() {
    const pct = this.hp / this.maxHP;
    const hungerPct = this.hunger / CONFIG.starvationThreshold;
    if (this.sleeping) return 'sleeping';
    if (pct < 0.15 || hungerPct > 0.9) return 'critical';
    if (pct < 0.4 || hungerPct > 0.7) return 'dim';
    if (pct > 0.7 && hungerPct < 0.3) return 'bright';
    return 'normal';
  }

  get effectiveInt() {
    const stressPenalty = this.stress / 100 * 0.8;
    return Math.max(0, this.genome.intelligence + (this.thinkTank || 0) - stressPenalty);
  }

  // Jack of all trades, master of none: high ADP slightly suppresses other genes
  get specPenalty() {
    return 1 - this.genome.adaptability * 0.15;
  }

  get perceptionRange() {
    return 2 + Math.floor(this.genome.perception * this.specPenalty * 6);
  }

  get moveSpeed() {
    return 1 + Math.floor(this.genome.speed * this.specPenalty * 2);
  }

  genomeSimilarity(other) {
    let sum = 0;
    for (const g of GENES) {
      sum += 1 - Math.abs(this.genome[g] - other.genome[g]);
    }
    return sum / GENES.length;
  }
}

// ============================================================
// GENETICS
// ============================================================
const Genetics = {
  createGenome(means, variance, rng) {
    const genome = {};
    for (const g of GENES) {
      const mean = means[g] ?? 0.5;
      const v = rng.gaussian(mean, variance);
      genome[g] = Math.max(0, Math.min(1, v));
    }
    return genome;
  },

  crossover(genomeA, genomeB, rng, traitFreq) {
    const child = {};
    const expected = 1 / GENES.length; // ~0.143 for 7 genes
    for (const g of GENES) {
      let w = rng.range(0.2, 0.8);
      // Frequency-dependent inheritance: rare traits boosted, dominant traits penalized
      if (traitFreq) {
        const freq = traitFreq[g] || 0;
        if (freq < expected) {
          // Rarity boost: underrepresented genes inherit stronger
          const rarityBoost = ((expected - freq) / expected) * 0.2;
          if (genomeA[g] >= genomeB[g]) {
            w = Math.min(0.95, w + rarityBoost);
          } else {
            w = Math.max(0.05, w - rarityBoost);
          }
        } else if (freq > expected * 3) {
          // Dominance penalty: heavily overrepresented genes regress toward mean
          const dominancePenalty = Math.min(0.15, (freq - expected * 3) * 0.3);
          // Blend toward LOWER parent value (regression)
          if (genomeA[g] >= genomeB[g]) {
            w = Math.max(0.05, w - dominancePenalty);
          } else {
            w = Math.min(0.95, w + dominancePenalty);
          }
        }
      }
      child[g] = genomeA[g] * w + genomeB[g] * (1 - w);
    }
    return child;
  },

  mutate(genome, rate, rng, burstMult = 1) {
    const result = { ...genome };
    // During mutation burst: wider gaussian variance + higher macro chance
    const variance = 0.08 * (1 + (burstMult - 1) * 0.3); // 0.08 normal → ~0.10 sev5 → ~0.32 sev10
    const macroChance = CONFIG.macroMutationChance * burstMult; // 2% normal → 12% sev5 → 22% sev10
    for (const g of GENES) {
      // Normal mutation
      if (rng.next() < rate) {
        result[g] += rng.gaussian(0, variance);
      }
      // Macro-mutation (complete random reset of this gene)
      if (rng.next() < macroChance) {
        result[g] = rng.next();
      }
      result[g] = Math.max(0, Math.min(1, result[g]));
    }
    return result;
  },

  reproduce(parentA, parentB, rng, traitFreq, mutRate, burstMult) {
    const blended = Genetics.crossover(parentA.genome, parentB.genome, rng, traitFreq);
    const mutated = Genetics.mutate(blended, mutRate || CONFIG.mutationRate, rng, burstMult || 1);
    return mutated;
  }
};

// ============================================================
// LURCH PRESETS
// ============================================================
const LURCH_PRESETS = {
  balanced:    { means: { vitality:0.5, speed:0.5, strength:0.5, intelligence:0.5, adaptability:0.5, perception:0.5, size:0.5 }, variance: 0.15 },
  warriors:    { means: { vitality:0.7, speed:0.5, strength:0.8, intelligence:0.3, adaptability:0.4, perception:0.5, size:0.7 }, variance: 0.12 },
  thinkers:    { means: { vitality:0.4, speed:0.3, strength:0.2, intelligence:0.8, adaptability:0.5, perception:0.7, size:0.3 }, variance: 0.12 },
  survivors:   { means: { vitality:0.7, speed:0.4, strength:0.4, intelligence:0.4, adaptability:0.8, perception:0.5, size:0.5 }, variance: 0.12 },
  chaos:       { means: { vitality:0.5, speed:0.5, strength:0.5, intelligence:0.5, adaptability:0.5, perception:0.5, size:0.5 }, variance: 0.35 },
  specialists: null, // handled specially
};

// ============================================================
// DECISION ENGINE
// ============================================================
const DecisionEngine = {
  decide(lurch, world) {
    const eInt = lurch.effectiveInt;

    // Sleeping lurches wake up if threatened or hungry
    if (lurch.sleeping) {
      if (lurch.energy >= 90 || lurch.hunger > 60 || lurch.stress > 50) {
        lurch.sleeping = false;
      } else {
        return { action: 'sleep' };
      }
    }

    // Settlement stickiness — cooperators in clusters stay put
    // At low population, ALL lurches feel group stickiness (survival instinct)
    const settleCS = (lurch.genome.intelligence + lurch.genome.perception) / 2
                   - (lurch.genome.strength + lurch.genome.size) / 4;
    const pop = world._popCount || 200;
    const isCooperator = settleCS > 0.2;
    const groupInstinct = isCooperator || pop < 100; // brutes stick at low pop too
    const settleHungerLimit = lurch.thinkTank > 0 ? 65 : 50; // academy members tolerate more hunger to stay
    if (groupInstinct && lurch.hunger < settleHungerLimit && lurch.stress < 60) {
      let sNeighbors = 0;
      for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
        const ally = world.getLurch(nx, ny);
        if (ally && ally.alive) {
          if (isCooperator) {
            // Cooperators count cooperator neighbors (full settlement behavior)
            const cs = (ally.genome.intelligence + ally.genome.perception) / 2
                     - (ally.genome.strength + ally.genome.size) / 4;
            if (cs > 0.2) sNeighbors++;
          } else {
            // Non-cooperators at low pop count ANY neighbor (survival grouping)
            sNeighbors++;
          }
        }
      }
      if (sNeighbors >= 2) {
        // Cooperators settle more readily; non-cooperators at low pop get a weaker version
        let stayChance = isCooperator
          ? Math.min(0.8, sNeighbors * 0.2)
          : Math.min(0.5, sNeighbors * 0.12); // weaker stickiness for brutes
        // Think tank stickiness: academy members lock in place
        if (lurch.thinkTank > 0) {
          // Count academy size (INT lurches within radius 4)
          let academySize = 0;
          for (const cell of world.cellsInRadius(lurch.x, lurch.y, 4)) {
            const m = world.getLurch(cell[0], cell[1]);
            if (m && m.alive && m !== lurch && m.genome.intelligence >= 0.3) academySize++;
          }
          lurch._academySize = academySize; // cache for rendering + other systems
          if (academySize <= 12) {
            stayChance = 0.98; // lockdown — academy members almost never leave
          } else {
            // Overcrowded academy: excess members drift off to spread knowledge
            stayChance = Math.max(0.3, 0.98 - (academySize - 12) * 0.1); // drops off sharply past 12
          }
        }
        if (world.rng.next() < stayChance) {
          lurch.lastAction = lurch.thinkTank > 0 ? 'thinking' : (isCooperator ? 'settled' : 'grouped');
          return { action: 'nothing' };
        }
      }
    }

    // Tier determination
    if (eInt < 0.2) return DecisionEngine.instinctive(lurch, world);
    if (eInt < 0.5) return DecisionEngine.aware(lurch, world);
    if (eInt < 0.8) return DecisionEngine.strategic(lurch, world);
    return DecisionEngine.brilliant(lurch, world);
  },

  // Low-pop scan bonus: when species is dwindling, lurches sense further
  lowPopScanBonus(world) {
    const pop = world._popCount || 200;
    if (pop >= 150) return 0;
    // Scales from +1 at 150 to +4 at pop 0
    return Math.ceil((150 - pop) / 150 * 4);
  },

  // Migration pull: bias wander direction toward population centroid
  // Returns a direction [dx, dy] or null if no pull active
  migrationPull(lurch, world) {
    const c = world._popCentroid;
    if (!c) return null;
    // Pull strength scales with INT + PER, everyone gets a base pull
    const sense = 0.3 + (lurch.genome.perception * 0.4 + lurch.genome.intelligence * 0.3);
    // Only pull when random check passes — not deterministic, just a bias
    if (world.rng.next() > sense) return null;
    return this.directionTo(world, lurch.x, lurch.y, c.x, c.y);
  },

  // INT beacon: long-range scan specifically for other INT lurches
  // Smart lurches can sense each other from much further than normal scan range
  intBeacon(lurch, world) {
    if (lurch.genome.intelligence < 0.3) return null;
    const beaconRange = 10 + Math.round(lurch.genome.intelligence * 10); // 10-20 tiles
    let closest = null;
    let closestDist = Infinity;
    let bestCluster = null;
    let bestClusterScore = 0;
    for (let dy = -beaconRange; dy <= beaconRange; dy++) {
      for (let dx = -beaconRange; dx <= beaconRange; dx++) {
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d > beaconRange || d < 2) continue;
        const nx = world.wrapX(lurch.x + dx);
        const ny = world.wrapY(lurch.y + dy);
        const other = world.getLurch(nx, ny);
        if (other && other.alive && other !== lurch && other.genome.intelligence >= 0.3) {
          if (d < closestDist) { closest = { x: nx, y: ny, dist: d }; closestDist = d; }
          // Score clusters: count INT neighbors around this target
          let clusterScore = other.genome.intelligence;
          if (other.thinkTank > 0) clusterScore += other.thinkTank * 3; // active academies are magnetic
          if (clusterScore > bestClusterScore) { bestCluster = { x: nx, y: ny, dist: d }; bestClusterScore = clusterScore; }
        }
      }
    }
    // Prefer active academies over lone thinkers
    return bestClusterScore > 0.5 ? bestCluster : closest;
  },

  // Scan surroundings for food, threats, mates, teachers
  scan(lurch, world, range) {
    const foods = [];
    const threats = [];
    const mates = [];
    const empty = [];
    const teachers = [];
    const companions = [];
    const thinkers = [];

    for (let dy = -range; dy <= range; dy++) {
      for (let dx = -range; dx <= range; dx++) {
        if (dx === 0 && dy === 0) continue;
        const [nx, ny] = world.wrap(lurch.x + dx, lurch.y + dy);
        const other = world.getLurch(nx, ny);
        const d = Math.max(Math.abs(dx), Math.abs(dy));
        const food = world.getFood(nx, ny);

        if (other && other.alive) {
          if (other.genome.strength > lurch.genome.strength * 0.8) {
            threats.push({ lurch: other, x: nx, y: ny, dist: d });
          }
          if (!lurch.juvenile && !other.juvenile && d <= 1) {
            mates.push({ lurch: other, x: nx, y: ny });
          }
          // Track nearby teachers (high INT lurches)
          if (other.genome.intelligence > 0.5) {
            teachers.push({ lurch: other, x: nx, y: ny, dist: d, int: other.genome.intelligence });
          }
          // Track companions (non-threatening lurches beyond mating range)
          if (d > 1 && !(other.genome.strength > lurch.genome.strength * 0.8)) {
            companions.push({ lurch: other, x: nx, y: ny, dist: d });
          }
          // Track thinkers (INT >= 0.3 lurches for think tank seeking)
          if (other.genome.intelligence >= 0.3 && d > 1) {
            thinkers.push({ lurch: other, x: nx, y: ny, dist: d, int: other.genome.intelligence });
          }
        }
        if (!other && food > 1 && !world.getTerrain(nx, ny).impassable) {
          foods.push({ x: nx, y: ny, food, dist: d });
        }
        if (!other && !world.getTerrain(nx, ny).impassable && d <= 1) {
          empty.push({ x: nx, y: ny });
        }
      }
    }
    // Shuffle to prevent directional bias from scan order
    const shuffle = (arr) => {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = world.rng.nextInt(i + 1);
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    };
    shuffle(foods); shuffle(threats); shuffle(empty); shuffle(mates); shuffle(teachers); shuffle(companions); shuffle(thinkers);
    return { foods, threats, mates, empty, teachers, companions, thinkers };
  },

  // Direction toward a target (toroidal)
  directionTo(world, fx, fy, tx, ty) {
    let dx = tx - fx;
    let dy = ty - fy;
    if (Math.abs(dx) > world.w / 2) dx -= Math.sign(dx) * world.w;
    if (Math.abs(dy) > world.h / 2) dy -= Math.sign(dy) * world.h;
    return [Math.sign(dx), Math.sign(dy)];
  },

  instinctive(lurch, world) {
    const { foods, threats, mates, empty, companions } = this.scan(lurch, world, 2 + this.lowPopScanBonus(world));

    // If very hungry, eat if food here
    if (lurch.hunger > 50 && world.getFood(lurch.x, lurch.y) > 0) return { action: 'eat' };

    // If very low energy, sleep
    if (lurch.energy < 15) return { action: 'sleep' };

    // Aggression: dumb brutes pick fights with weaker neighbors
    // Low INT + high STR/SIZ = aggressive
    let aggression = (lurch.genome.strength + lurch.genome.size) / 2 - (lurch.genome.intelligence + lurch.genome.perception) / 2;
    // Low-population dampening: when everyone's scarce, even brutes hold back
    const pop = world._popCount || 200;
    if (pop < 100) aggression *= Math.max(0.3, pop / 100);
    // STR overpopulation infighting: too many warriors = territorial fights over resources
    const strFrac = world._strFraction || 0;
    if (strFrac > 0.25 && aggression > 0) {
      aggression *= 1 + (strFrac - 0.25) * 2; // at 50% STR, aggression x1.5 — they fight each other more
    }
    if (aggression > 0.2 && lurch.energy > 20 && lurch.combatCooldown <= 0) {
      // Look for weaker adjacent lurches to bully
      for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
        const other = world.getLurch(nx, ny);
        if (other && other.alive && other !== lurch) {
          const myPower = lurch.genome.strength * 0.6 + lurch.genome.size * 0.4;
          // INT deterrence: smart lurches look dangerous — they might be tricky
          const intDeter = other.effectiveInt * 0.3; // INT adds perceived toughness
          const theirPower = other.genome.strength * 0.6 + other.genome.size * 0.4 + intDeter;
          // Threat deterrence: count cooperator allies near target
          let coopAllies = 0;
          for (const [ax, ay] of world.neighbors8(other.x, other.y)) {
            const ally = world.getLurch(ax, ay);
            if (ally && ally.alive && ally !== lurch && ally !== other) {
              const cs = (ally.genome.intelligence + ally.genome.perception) / 2
                       - (ally.genome.strength + ally.genome.size) / 4;
              if (cs > 0.2) coopAllies++;
            }
          }
          const deterrence = 1 + coopAllies * 0.25; // each ally makes target look 25% tougher
          if (myPower > theirPower * 0.8 * deterrence && world.rng.next() < aggression) {
            return { action: 'fight', target: other };
          }
        }
      }
    }

    // Fight or flee from adjacent threat (coin flip)
    if (threats.length > 0 && threats[0].dist <= 1) {
      return world.rng.next() < 0.5 ? { action: 'fight', target: threats[0].lurch } : { action: 'move', dir: this.directionTo(world, lurch.x, lurch.y, threats[0].x, threats[0].y).map(d => -d) };
    }

    // Mate with anyone adjacent
    if (!lurch.juvenile && mates.length > 0 && lurch.energy > 30 && lurch.hunger < 70) {
      return { action: 'reproduce', mate: world.rng.pick(mates).lurch };
    }

    // Seek companions when hungry (group up when resources are tight)
    if (lurch.hunger > 30 && companions.length > 0) {
      companions.sort((a, b) => a.dist - b.dist);
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, companions[0].x, companions[0].y);
      return { action: 'move', dir: [dx, dy] };
    }

    // INT beacon: even instinctive INT lurches feel drawn toward each other
    const beacon = this.intBeacon(lurch, world);
    if (beacon) {
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, beacon.x, beacon.y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Migration pull: drift toward population center when species is sparse
    const pull = this.migrationPull(lurch, world);
    if (pull) return { action: 'move', dir: pull };

    // Random movement
    if (world.rng.next() < 0.6) {
      return { action: 'move', dir: [world.rng.nextInt(3) - 1, world.rng.nextInt(3) - 1] };
    }

    return { action: 'nothing' };
  },

  aware(lurch, world) {
    const scan = this.scan(lurch, world, 3 + this.lowPopScanBonus(world));

    // Flee from stronger threats
    if (scan.threats.length > 0 && scan.threats[0].dist <= 2) {
      if (lurch.hp / lurch.maxHP < 0.5 || lurch.genome.strength < scan.threats[0].lurch.genome.strength) {
        const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, scan.threats[0].x, scan.threats[0].y);
        return lurch.energy > CONFIG.hideEnergyCost + 5 ? { action: 'hide' } : { action: 'move', dir: [-dx, -dy] };
      }
    }

    // Eat if hungry and food here
    if (lurch.hunger > 40 && world.getFood(lurch.x, lurch.y) > 1) return { action: 'eat' };

    // Academy lockdown: INT lurches in a think tank STOP. Food bonus sustains them.
    if (lurch.thinkTank > 0) {
      const oversize = (lurch._academySize || 0) > 12;
      if (!oversize) {
        // Core academy: eat, reproduce, or hold — never leave
        if (world.getFood(lurch.x, lurch.y) > 0) return { action: 'eat' };
        if (!lurch.juvenile && scan.mates.length > 0 && lurch.energy > 35) return { action: 'reproduce', mate: world.rng.pick(scan.mates).lurch };
        if (lurch.hunger < 75) return { action: 'nothing' }; // hold even when hungry — food will regrow
        // Only if truly starving, forage within 2 tiles
        const nearFood = scan.foods.filter(f => f.dist <= 2);
        if (nearFood.length > 0) {
          const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, nearFood[0].x, nearFood[0].y);
          return { action: 'move', dir: [dx, dy] };
        }
        return { action: 'nothing' }; // even starving, try to hold
      }
      // Oversized academy: this lurch should drift off — skip lockdown
    }

    // Think tank seeking: INT lurches seek other thinkers (before food-chasing)
    if (lurch.genome.intelligence >= 0.3 && scan.thinkers.length > 0) {
      scan.thinkers.sort((a, b) => b.int - a.int);
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, scan.thinkers[0].x, scan.thinkers[0].y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Move toward visible food
    if (lurch.hunger > 30 && scan.foods.length > 0) {
      scan.foods.sort((a, b) => b.food / (b.dist + 1) - a.food / (a.dist + 1));
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, scan.foods[0].x, scan.foods[0].y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Sleep if tired
    if (lurch.energy < 25) return { action: 'sleep' };

    // Reproduce
    if (!lurch.juvenile && scan.mates.length > 0 && lurch.energy > 35 && lurch.hunger < 60) {
      return { action: 'reproduce', mate: world.rng.pick(scan.mates).lurch };
    }

    // Teacher-seeking: taught lurches drift toward teachers instead of wandering
    if (lurch.taught > 0 && scan.teachers.length > 0) {
      scan.teachers.sort((a, b) => b.int - a.int);
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, scan.teachers[0].x, scan.teachers[0].y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Seek companions when hungry (group up when resources are tight)
    if (lurch.hunger > 30 && scan.companions.length > 0) {
      scan.companions.sort((a, b) => a.dist - b.dist);
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, scan.companions[0].x, scan.companions[0].y);
      return { action: 'move', dir: [dx, dy] };
    }

    // INT beacon: sense distant INT lurches and move toward them
    const beacon = this.intBeacon(lurch, world);
    if (beacon) {
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, beacon.x, beacon.y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Migration pull
    const pull = this.migrationPull(lurch, world);
    if (pull) return { action: 'move', dir: pull };

    // Wander
    return { action: 'move', dir: [world.rng.nextInt(3) - 1, world.rng.nextInt(3) - 1] };
  },

  strategic(lurch, world) {
    const range = lurch.perceptionRange + this.lowPopScanBonus(world);
    const scan = this.scan(lurch, world, range);

    // Retreat to safe terrain if injured
    if (lurch.hp / lurch.maxHP < 0.4) {
      const terrain = world.getTerrain(lurch.x, lurch.y);
      if (terrain.safety < 3) {
        // Find safer terrain
        for (const f of scan.foods) {
          if (world.getTerrain(f.x, f.y).safety >= 4) {
            const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, f.x, f.y);
            return { action: 'move', dir: [dx, dy] };
          }
        }
      }
      if (lurch.energy < 20) return { action: 'sleep' };
      return { action: 'hide' };
    }

    // Evaluate threats — flee if outmatched
    if (scan.threats.length > 0) {
      const threat = scan.threats[0];
      if (threat.dist <= 2 && threat.lurch.genome.strength > lurch.genome.strength * 1.1) {
        const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, threat.x, threat.y);
        return { action: 'move', dir: [-dx, -dy] };
      }
    }

    // Eat strategically (wait for good food cells)
    if (lurch.hunger > 35 && world.getFood(lurch.x, lurch.y) > 2) return { action: 'eat' };

    // Academy lockdown: strategic INT lurches in think tank STOP
    if (lurch.thinkTank > 0) {
      const oversize = (lurch._academySize || 0) > 12;
      if (!oversize) {
        if (world.getFood(lurch.x, lurch.y) > 0) return { action: 'eat' };
        if (!lurch.juvenile && scan.mates.length > 0 && lurch.energy > 40) {
          scan.mates.sort((a, b) => {
            const sa = GENES.reduce((s, g) => s + b.lurch.genome[g], 0);
            const sb = GENES.reduce((s, g) => s + a.lurch.genome[g], 0);
            return sa - sb;
          });
          return { action: 'reproduce', mate: scan.mates[0].lurch };
        }
        if (lurch.hunger < 75) return { action: 'nothing' };
        const nearFood = scan.foods.filter(f => f.dist <= 2);
        if (nearFood.length > 0) {
          const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, nearFood[0].x, nearFood[0].y);
          return { action: 'move', dir: [dx, dy] };
        }
        return { action: 'nothing' };
      }
    }

    // Think tank seeking: strategic INT lurches actively seek thinker clusters
    if (lurch.genome.intelligence >= 0.3 && scan.thinkers.length > 0) {
      scan.thinkers.sort((a, b) => b.int - a.int);
      const best = scan.thinkers[0];
      if (best.dist <= 1) {
        if (world.getFood(lurch.x, lurch.y) > 1) return { action: 'eat' };
        return { action: 'nothing' };
      }
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, best.x, best.y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Pathfind toward food-rich areas
    if (lurch.hunger > 25) {
      scan.foods.sort((a, b) => b.food - a.food);
      if (scan.foods.length > 0) {
        const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, scan.foods[0].x, scan.foods[0].y);
        return { action: 'move', dir: [dx, dy] };
      }
    }

    // Stockpile energy before reproducing (settlements make this easier)
    if (!lurch.juvenile && scan.mates.length > 0 && lurch.energy > 40 && lurch.hunger < 55) {
      scan.mates.sort((a, b) => {
        const sa = GENES.reduce((s, g) => s + b.lurch.genome[g], 0);
        const sb = GENES.reduce((s, g) => s + a.lurch.genome[g], 0);
        return sa - sb;
      });
      return { action: 'reproduce', mate: scan.mates[0].lurch };
    }

    if (lurch.energy < 30) return { action: 'sleep' };

    // Teacher-seeking: taught lurches prefer areas near teachers over random food
    if (lurch.taught > 0 && scan.teachers.length > 0) {
      scan.teachers.sort((a, b) => b.int - a.int);
      const teacher = scan.teachers[0];
      if (teacher.dist <= 1) {
        if (world.getFood(lurch.x, lurch.y) > 1) return { action: 'eat' };
        return { action: 'nothing' };
      }
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, teacher.x, teacher.y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Wander toward food areas
    if (scan.foods.length > 0) {
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, scan.foods[0].x, scan.foods[0].y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Seek companions when hungry (group up when resources are tight)
    if (lurch.hunger > 25 && scan.companions.length > 0) {
      scan.companions.sort((a, b) => a.dist - b.dist);
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, scan.companions[0].x, scan.companions[0].y);
      return { action: 'move', dir: [dx, dy] };
    }

    // INT beacon: sense distant INT lurches and move toward them
    const beacon = this.intBeacon(lurch, world);
    if (beacon) {
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, beacon.x, beacon.y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Migration pull
    const pull = this.migrationPull(lurch, world);
    if (pull) return { action: 'move', dir: pull };

    return { action: 'move', dir: [world.rng.nextInt(3) - 1, world.rng.nextInt(3) - 1] };
  },

  brilliant(lurch, world) {
    const range = lurch.perceptionRange + 2 + this.lowPopScanBonus(world);
    const scan = this.scan(lurch, world, range);
    const terrain = world.getTerrain(lurch.x, lurch.y);

    // Avoid swamp disease
    if (terrain.disease && !lurch.diseased && lurch.genome.adaptability < 0.6) {
      for (const c of scan.empty || this.scan(lurch, world, 2).empty) {
        const t = world.getTerrain(c.x, c.y);
        if (!t.disease) {
          const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, c.x, c.y);
          return { action: 'move', dir: [dx, dy] };
        }
      }
    }

    // Avoid desert without energy reserves
    if (terrain === TERRAIN.DESERT && lurch.energy < 40) {
      for (const f of scan.foods) {
        const t = world.getTerrain(f.x, f.y);
        if (t !== TERRAIN.DESERT) {
          const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, f.x, f.y);
          return { action: 'move', dir: [dx, dy] };
        }
      }
    }

    // Smart threat assessment
    if (scan.threats.length > 0) {
      const threat = scan.threats[0];
      // Only fight if we have significant advantage — factor in cooperator allies
      let tCoopAllies = 0;
      for (const [ax, ay] of world.neighbors8(threat.x, threat.y)) {
        const ally = world.getLurch(ax, ay);
        if (ally && ally.alive && ally !== lurch && ally !== threat.lurch) {
          const cs = (ally.genome.intelligence + ally.genome.perception) / 2
                   - (ally.genome.strength + ally.genome.size) / 4;
          if (cs > 0.2) tCoopAllies++;
        }
      }
      const tDeterrence = 1 + tCoopAllies * 0.25;
      if (threat.dist <= 1 && lurch.genome.strength > threat.lurch.genome.strength * 1.3 * tDeterrence && lurch.hp / lurch.maxHP > 0.6) {
        return { action: 'fight', target: threat.lurch };
      }
      // Otherwise retreat smartly
      if (threat.dist <= 3) {
        const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, threat.x, threat.y);
        // Move to safe terrain while fleeing
        return { action: 'move', dir: [-dx, -dy] };
      }
    }

    // Academy lockdown: brilliant INT lurches in think tank STOP
    if (lurch.thinkTank > 0) {
      const oversize = (lurch._academySize || 0) > 12;
      if (!oversize) {
        if (world.getFood(lurch.x, lurch.y) > 0) return { action: 'eat' };
        if (!lurch.juvenile && scan.mates.length > 0 && lurch.energy > 40) {
          const scored = scan.mates.map(m => {
            let score = 0;
            for (const g of GENES) score += m.lurch.genome[g];
            if (m.lurch.dominantGene !== lurch.dominantGene) score += 1;
            return { ...m, score };
          }).sort((a, b) => b.score - a.score);
          return { action: 'reproduce', mate: scored[0].lurch };
        }
        if (lurch.hunger < 75) return { action: 'nothing' };
        const nearFood = scan.foods.filter(f => f.dist <= 2);
        if (nearFood.length > 0) {
          nearFood.sort((a, b) => b.food * world.getTerrain(b.x, b.y).safety - a.food * world.getTerrain(a.x, a.y).safety);
          const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, nearFood[0].x, nearFood[0].y);
          return { action: 'move', dir: [dx, dy] };
        }
        return { action: 'nothing' };
      }
    }

    // Think tank seeking: brilliant INT lurches prioritize thinker clusters
    if (lurch.genome.intelligence >= 0.3 && scan.thinkers.length > 0) {
      scan.thinkers.sort((a, b) => b.int - a.int);
      const best = scan.thinkers[0];
      if (best.dist <= 1) {
        if (world.getFood(lurch.x, lurch.y) > 1) return { action: 'eat' };
        if (terrain.safety >= 3) return { action: 'nothing' }; // hold near thinker
      }
      if (best.dist <= 5) {
        const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, best.x, best.y);
        return { action: 'move', dir: [dx, dy] };
      }
    }

    // Teacher-seeking: brilliant taught lurches actively orbit teachers
    if (lurch.taught > 0 && scan.teachers.length > 0) {
      scan.teachers.sort((a, b) => b.int - a.int);
      const teacher = scan.teachers[0];
      if (teacher.dist <= 1) {
        if (world.getFood(lurch.x, lurch.y) > 1) return { action: 'eat' };
        if (terrain.safety >= 3) return { action: 'nothing' };
      }
      if (teacher.dist <= 4) {
        const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, teacher.x, teacher.y);
        return { action: 'move', dir: [dx, dy] };
      }
    }

    // Optimal eating
    if (lurch.hunger > 30 && world.getFood(lurch.x, lurch.y) > 3) return { action: 'eat' };

    // Find best food considering terrain safety
    if (lurch.hunger > 20) {
      const scored = scan.foods.map(f => ({
        ...f,
        score: f.food * world.getTerrain(f.x, f.y).safety / (f.dist + 1)
      })).sort((a, b) => b.score - a.score);
      if (scored.length > 0) {
        const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, scored[0].x, scored[0].y);
        return { action: 'move', dir: [dx, dy] };
      }
    }

    // Reproduce with optimal mates (complementary stats)
    if (!lurch.juvenile && scan.mates.length > 0 && lurch.energy > 45 && lurch.hunger < 50) {
      const scored = scan.mates.map(m => {
        let score = 0;
        for (const g of GENES) score += m.lurch.genome[g];
        // Prefer complementary (different dominant gene)
        if (m.lurch.dominantGene !== lurch.dominantGene) score += 1;
        return { ...m, score };
      }).sort((a, b) => b.score - a.score);
      return { action: 'reproduce', mate: scored[0].lurch };
    }

    // Kin warning: emit danger signal
    if (scan.threats.length > 0 && lurch.genome.intelligence >= 0.6) {
      for (const cell of world.cellsInRadius(lurch.x, lurch.y, lurch.perceptionRange)) {
        const other = world.getLurch(cell[0], cell[1]);
        if (other && other !== lurch && other.alive && lurch.genomeSimilarity(other) > CONFIG.kinSimilarityThreshold) {
          other.warned = true;
        }
      }
    }

    if (lurch.energy < 35) return { action: 'sleep' };

    // Territory behavior: return to known good area (high food, safe)
    if (terrain.safety >= 4 && world.getFood(lurch.x, lurch.y) > 1) {
      return { action: 'nothing' }; // Hold position
    }

    // Move toward promising areas
    if (scan.foods.length > 0) {
      const best = scan.foods.sort((a, b) => b.food * world.getTerrain(b.x, b.y).safety - a.food * world.getTerrain(a.x, a.y).safety)[0];
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, best.x, best.y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Seek companions when hungry (group up when resources are tight)
    if (lurch.hunger > 20 && scan.companions.length > 0) {
      scan.companions.sort((a, b) => a.dist - b.dist);
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, scan.companions[0].x, scan.companions[0].y);
      return { action: 'move', dir: [dx, dy] };
    }

    // INT beacon: sense distant INT lurches and move toward them
    const beacon = this.intBeacon(lurch, world);
    if (beacon) {
      const [dx, dy] = this.directionTo(world, lurch.x, lurch.y, beacon.x, beacon.y);
      return { action: 'move', dir: [dx, dy] };
    }

    // Migration pull
    const pull = this.migrationPull(lurch, world);
    if (pull) return { action: 'move', dir: pull };

    return { action: 'move', dir: [world.rng.nextInt(3) - 1, world.rng.nextInt(3) - 1] };
  }
};

// ============================================================
// EVENTS (GOD MODE)
// ============================================================
const Events = {
  activeEvents: [],
  vfx: [], // Visual effects: { type, x, y, ttl, maxTtl, radius? }

  add(event) {
    this.activeEvents.push(event);
  },

  addVfx(type, x, y, ttl, extra = {}) {
    this.vfx.push({ type, x, y, ttl, maxTtl: ttl, ...extra });
  },

  tick(world, sim) {
    this.activeEvents = this.activeEvents.filter(e => {
      e.duration--;
      if (e.tick) e.tick(world, sim);
      return e.duration > 0;
    });
    // Decay VFX
    this.vfx = this.vfx.filter(v => { v.ttl--; return v.ttl > 0; });
  },

  // Severity helper: scales a value. sev 1-10, 5 = default (1x).
  // At sev 1 → 0.2x, sev 5 → 1x, sev 10 → 2x
  sev(base) { const s = this._severity || 5; return base * (0.2 + (s - 1) * 0.2); },
  sevInt(base) { return Math.max(1, Math.round(this.sev(base))); },

  drought(world, sim) {
    const dur = this.sevInt(50);
    const mult = Math.max(0.05, 0.7 - this._severity * 0.06); // sev1=0.64, sev5=0.4, sev10=0.1
    this.add({ name: 'Drought', duration: dur, tick(w) {}, foodMult: mult, vfxType: 'drought' });
    sim.log(`DROUGHT [${this._severity}] — food regen ×${mult.toFixed(2)} for ${dur} rounds`, 'event');
  },

  flood(world, sim) {
    const spreadChance = 0.2 + this._severity * 0.07; // 0.27 to 0.9
    const waves = this._severity * 2; // sev1=2, sev5=10, sev10=20 waves deep
    let totalFlooded = 0;
    let kills = 0;

    // Rainfall: spawn random flood sources across the map (scales with severity)
    // This makes floods deadly even on landlocked maps like Eden
    const rainfallSources = Math.round(this._severity * this._severity * 0.5); // sev1=0, sev5=12, sev10=50
    for (let i = 0; i < rainfallSources; i++) {
      const rx = world.rng.nextInt(world.w);
      const ry = world.rng.nextInt(world.h);
      const t = world.getTerrain(rx, ry);
      if (t !== TERRAIN.DEEP_WATER && t !== TERRAIN.SHALLOWS && t !== TERRAIN.MOUNTAIN && t !== TERRAIN.WALL) {
        world.setTerrain(rx, ry, TERRAIN.SHALLOWS);
        this.addVfx('flood', rx, ry, 40);
        totalFlooded++;
        const l = world.getLurch(rx, ry);
        if (l && l.alive) {
          l.hp = 0; l.causeOfDeath = 'flood'; kills++;
        }
      }
    }

    for (let wave = 0; wave < waves; wave++) {
      const toConvert = [];
      for (let y = 0; y < world.h; y++) {
        for (let x = 0; x < world.w; x++) {
          if (world.getTerrain(x, y) === TERRAIN.DEEP_WATER || world.getTerrain(x, y) === TERRAIN.SHALLOWS) {
            for (const [nx, ny] of world.neighbors8(x, y)) {
              const t = world.getTerrain(nx, ny);
              if (t !== TERRAIN.DEEP_WATER && t !== TERRAIN.SHALLOWS && t !== TERRAIN.MOUNTAIN && t !== TERRAIN.WALL) {
                if (world.rng.next() < spreadChance) toConvert.push([nx, ny]);
              }
            }
          }
        }
      }
      for (const [x, y] of toConvert) {
        const l = world.getLurch(x, y);
        if (l && l.alive) {
          const killChance = 0.3 + this._severity * 0.07; // sev1=0.37, sev10=1.0
          if (world.rng.next() < killChance) {
            l.hp = 0; l.causeOfDeath = 'flood'; kills++;
          } else {
            l.hp -= this.sevInt(30);
          }
        }
        world.setTerrain(x, y, TERRAIN.SHALLOWS);
        this.addVfx('flood', x, y, 30 + Math.min(wave, 8) * 5);
        totalFlooded++;
      }
    }
    sim.log(`FLOOD [${this._severity}] — ${totalFlooded} cells flooded, ${kills} drowned (${waves} waves)`, 'event');
  },

  wildfire(world, sim) {
    // Find ignition center — prefer forest but accept anything burnable
    let cx, cy, attempts = 0;
    do {
      cx = world.rng.nextInt(world.w);
      cy = world.rng.nextInt(world.h);
      attempts++;
    } while (world.getTerrain(cx, cy) !== TERRAIN.FOREST && attempts < 200);

    // Scale to match meteor impact: big initial blast, then raging spread
    const sev = this._severity;
    const igniteRadius = Math.max(1, Math.round(sev * 0.6));  // sev1=1, sev5=3, sev10=6
    const spreadRate = 0.25 + sev * 0.07;   // sev1=0.32, sev5=0.60, sev10=0.95
    const maxBurn = Math.round(80 + sev * sev * 5); // sev1=85, sev5=205, sev10=580
    const dur = Math.round(15 + sev * 5);   // sev1=20, sev5=40, sev10=65 rounds
    const killChance = 0.15 + sev * 0.08;   // sev1=0.23, sev10=0.95
    const dmg = this.sevInt(40);
    const self = this;

    const burnedSet = new Set();
    const frontier = []; // cells currently on fire (spreading edge)
    const activeFires = new Set(); // track frontier cells for bright-edge VFX

    function igniteCell(x, y, isFrontier) {
      const key = `${x},${y}`;
      if (burnedSet.has(key)) return;
      const t = world.getTerrain(x, y);
      const burnable = [TERRAIN.FOREST, TERRAIN.PLAINS, TERRAIN.SWAMP, TERRAIN.LUSH_FOREST, TERRAIN.FERTILE_PLAINS];
      if (!burnable.includes(t)) return;
      burnedSet.add(key);
      frontier.push([x, y]);
      activeFires.add(key);
      // Burn terrain — enhanced terrain reverts to base Plains
      world.setTerrain(x, y, TERRAIN.PLAINS);
      world.setFood(x, y, 0);
      // Kill/hurt lurches
      const l = world.getLurch(x, y);
      if (l && l.alive) {
        if (world.rng.next() < killChance) {
          l.hp = 0; l.causeOfDeath = 'wildfire';
        } else {
          l.hp -= dmg;
        }
      }
      // VFX: bright raging fire at frontier, longer ash trail behind
      self.addVfx('fire', x, y, 20 + Math.floor(Math.random() * 15), { zone: 'perimeter' });
      self.addVfx('ash', x, y, 80 + dur * 2 + Math.floor(Math.random() * 40));
    }

    // Initial ignition: burn a square zone (like meteor blast)
    for (let dy = -igniteRadius; dy <= igniteRadius; dy++) {
      for (let dx = -igniteRadius; dx <= igniteRadius; dx++) {
        const [nx, ny] = world.wrap(cx + dx, cy + dy);
        igniteCell(nx, ny, true);
      }
    }

    // Ongoing spreading fire — each tick the frontier expands aggressively
    this.add({
      name: 'Wildfire', duration: dur, vfxType: 'wildfire',
      tick(w) {
        if (burnedSet.size >= maxBurn || frontier.length === 0) return;
        const currentFrontier = frontier.splice(0, frontier.length);
        // Clear old frontier markers
        for (const [fx, fy] of currentFrontier) {
          activeFires.delete(`${fx},${fy}`);
        }
        for (const [fx, fy] of currentFrontier) {
          for (const [nx, ny] of w.neighbors8(fx, fy)) {
            if (burnedSet.size >= maxBurn) return;
            const nKey = `${nx},${ny}`;
            if (burnedSet.has(nKey)) continue;
            const nt = w.getTerrain(nx, ny);
            let chance = spreadRate;
            if (nt === TERRAIN.LUSH_FOREST) chance *= 1.8;
            else if (nt === TERRAIN.FOREST) chance *= 1.5;
            else if (nt === TERRAIN.FERTILE_PLAINS) chance *= 0.5;
            else if (nt === TERRAIN.SWAMP) chance *= 0.6;
            else if (nt === TERRAIN.PLAINS) chance *= 0.3;
            else continue;
            if (w.rng.next() < chance) {
              igniteCell(nx, ny, true);
              // Extra VFX: bright flare at new frontier cells
              self.addVfx('fire', nx, ny, 18 + Math.floor(Math.random() * 12), { zone: 'perimeter' });
            }
          }
        }
      }
    });
    const ignited = burnedSet.size;
    sim.log(`WILDFIRE [${sev}] — Ignited ${ignited} cells at (${cx},${cy}), radius ${igniteRadius}, spreading...`, 'event');
  },

  earthquake(world, sim) {
    const cx = world.rng.nextInt(world.w);
    const cy = world.rng.nextInt(world.h);
    const radius = this.sevInt(10);
    let changed = 0;
    let kills = 0;
    const terrainPool = [TERRAIN.PLAINS, TERRAIN.MOUNTAIN, TERRAIN.FOREST, TERRAIN.RUINS, TERRAIN.SWAMP];
    for (const [x, y] of world.cellsInRadius(cx, cy, radius)) {
      // Distance from epicenter (toroidal)
      let dx = Math.abs(x - cx); if (dx > world.w / 2) dx = world.w - dx;
      let dy = Math.abs(y - cy); if (dy > world.h / 2) dy = world.h - dy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const distRatio = dist / Math.max(radius, 1); // 0 at center, 1 at edge

      // Terrain scramble — higher chance near center
      if (world.rng.next() < 0.8 - distRatio * 0.5) {
        world.setTerrain(x, y, world.rng.pick(terrainPool));
        changed++;
      }

      // Lurch damage — lethal at epicenter, decreasing with distance
      const l = world.getLurch(x, y);
      if (l && l.alive) {
        const sevScale = this._severity / 10; // 0.1 to 1.0
        if (distRatio < 0.3) {
          // Ground zero — everything dies
          l.hp = 0; l.causeOfDeath = 'earthquake'; kills++;
        } else if (distRatio < 0.6) {
          // Inner zone — high kill chance, scales with severity
          if (world.rng.next() < 0.5 + sevScale * 0.45) {
            l.hp = 0; l.causeOfDeath = 'earthquake'; kills++;
          } else {
            l.hp -= Math.round(l.hp * 0.8);
          }
        } else {
          // Outer zone — moderate kill chance at high severity, heavy damage
          const outerKill = sevScale * (1 - distRatio) * 1.5;
          if (world.rng.next() < outerKill) {
            l.hp = 0; l.causeOfDeath = 'earthquake'; kills++;
          } else {
            l.hp -= Math.round(this.sevInt(40) * (1 - distRatio));
          }
        }
      }
    }
    // VFX: seismic pulse from epicenter
    for (const [x, y] of world.cellsInRadius(cx, cy, radius)) {
      this.addVfx('quake', x, y, 15 + Math.floor(Math.random() * 10));
    }
    sim.log(`EARTHQUAKE [${this._severity}] at (${cx},${cy}) — ${changed} cells scrambled, ${kills} killed`, 'event');
  },

  meteor(world, sim) {
    const cx = world.rng.nextInt(world.w);
    const cy = world.rng.nextInt(world.h);
    const radius = Math.max(1, Math.round(1 + this._severity * 0.8));
    let kills = 0;
    for (const [x, y] of world.cellsInRadius(cx, cy, radius)) {
      world.setTerrain(x, y, TERRAIN.DESERT);
      world.setFood(x, y, 0);
      const l = world.getLurch(x, y);
      if (l && l.alive) { l.hp = 0; l.causeOfDeath = 'meteor'; kills++; }
    }
    // VFX: explosion/scorch at impact site
    for (const [x, y] of world.cellsInRadius(cx, cy, radius)) {
      this.addVfx('explosion', x, y, 40 + Math.floor(Math.random() * 20));
    }
    // Flash at epicenter
    this.addVfx('explosion', cx, cy, 60);
    sim.log(`METEOR [${this._severity}] at (${cx},${cy}) — radius ${radius}, ${kills} killed`, 'event');
  },

  iceage(world, sim) {
    const dur = this.sevInt(80);
    const mult = Math.max(0.05, 0.5 - this._severity * 0.04);
    const coldDmg = Math.round(this._severity * 0.8);
    this.add({
      name: 'Ice Age', duration: dur, foodMult: mult, vfxType: 'iceage',
      tick(w, s) {
        // Cold damage every 5 rounds — hurts lurches with low vitality
        if (s.round % 5 === 0) {
          for (const l of w.lurches) {
            if (!l.alive) continue;
            const coldResist = l.genome.vitality * 0.5 + l.genome.size * 0.3 + l.genome.adaptability * 0.2;
            if (w.rng.next() > coldResist) {
              l.hp -= coldDmg;
              if (l.hp <= 0) l.causeOfDeath = 'frostbite';
            }
          }
        }
      }
    });
    // Convert desert to plains (frozen)
    for (let i = 0; i < world.w * world.h; i++) {
      if (world.terrain[i] === TERRAIN.DESERT) {
        world.terrain[i] = TERRAIN.PLAINS;
      }
    }
    // Freeze some shallows
    for (let i = 0; i < world.w * world.h; i++) {
      if (world.terrain[i] === TERRAIN.SHALLOWS && world.rng.next() < 0.3 + this._severity * 0.05) {
        world.terrain[i] = TERRAIN.PLAINS;
      }
    }
    sim.log(`ICE AGE [${this._severity}] — food ×${mult.toFixed(2)} for ${dur} rounds, cold dmg ${coldDmg}/5rds`, 'event');
  },

  fertile(world, sim) {
    const dur = this.sevInt(40);
    const foodMult = 1 + this._severity * 0.3;
    const fertMult = 1 + this._severity * 0.2; // sev5 → 2x fertility, sev10 → 3x
    this.add({ name: 'Fertile Season', duration: dur, foodMult, fertMult });
    sim.log(`FERTILE SEASON [${this._severity}] — food ×${foodMult.toFixed(1)}, fertility ×${fertMult.toFixed(1)} for ${dur} rounds`, 'event');
  },

  plague(world, sim) {
    if (world.lurches.length === 0) return;
    // Phase 1: Patient zero starts the contagion
    const patient0 = world.rng.pick(world.lurches.filter(l => l.alive));
    if (!patient0) return;
    patient0.diseased = true;
    patient0.diseaseTurns = this.sevInt(40); // longer initial infection
    // Phase 2: Weak lurches get infected immediately (low adaptability)
    const threshold = 0.65 - this._severity * 0.03; // sev5 → 0.5, sev10 → 0.35
    const chance = 0.25 + this._severity * 0.06;
    let infected = 1; // count patient zero
    for (const l of world.lurches) {
      if (l.alive && !l.diseased && l.genome.adaptability < threshold && world.rng.next() < chance) {
        l.diseased = true;
        l.diseaseTurns = this.sevInt(30);
        infected++;
      }
    }
    // Phase 3: Ongoing contagion spreads from infected to neighbors each tick
    const spreadRate = 0.08 + this._severity * 0.04; // stronger spread
    const dur = this.sevInt(50); // lingers much longer
    this.add({
      name: 'Plague', duration: dur,
      tick(w) {
        for (const l of w.lurches) {
          if (!l.alive || !l.diseased) continue;
          // Spread to neighbors — range 2 so it jumps gaps
          for (const cell of w.cellsInRadius(l.x, l.y, 2)) {
            const other = w.getLurch(cell[0], cell[1]);
            if (other && other.alive && !other.diseased) {
              const resist = Math.sqrt(other.genome.vitality) * 0.6 + other.genome.adaptability * 0.25;
              if (w.rng.next() < spreadRate * (1 - resist)) {
                other.diseased = true;
                other.diseaseTurns = 15 + w.rng.nextInt(15);
              }
            }
          }
        }
      }
    });
    sim.log(`PLAGUE [${this._severity}] — Patient zero: #${patient0.id}, ${infected} initially infected, contagion spreading...`, 'event');
  },

  mutationburst(world, sim) {
    const dur = this.sevInt(30);
    const mult = 1 + this._severity * 1.0; // sev1=2x, sev5=6x, sev10=11x
    this.add({ name: 'Mutation Burst', duration: dur, mutMult: mult });
    const macroChance = Math.round(CONFIG.macroMutationChance * mult * 100);
    sim.log(`MUTATION BURST [${this._severity}] — mutation rate ×${mult.toFixed(0)}, macro chance ${macroChance}% for ${dur} rounds`, 'event');
  },


  bottleneck(world, sim) {
    const killChance = 0.1 + this._severity * 0.08; // 0.18 to 0.9
    let kills = 0;
    for (const l of world.lurches) {
      if (l.alive && world.rng.next() < killChance) {
        l.hp = 0;
        l.causeOfDeath = 'bottleneck';
        kills++;
      }
    }
    sim.log(`GENETIC BOTTLENECK [${this._severity}] — ${kills} Lurches killed (${Math.round(killChance*100)}% chance)`, 'event');
  },

  rejuvenation(world, sim) {
    const healPct = 0.2 + this._severity * 0.06;
    const hungerReduce = 10 + this._severity * 5;
    const energyGain = 10 + this._severity * 5;
    for (const l of world.lurches) {
      if (l.alive) {
        l.hp = Math.min(l.maxHP, l.hp + l.maxHP * healPct);
        l.hunger = Math.max(0, l.hunger - hungerReduce);
        l.energy = Math.min(100, l.energy + energyGain);
      }
    }
    sim.log(`REJUVENATION [${this._severity}] — all Lurches healed (${Math.round(healPct*100)}% HP)`, 'event');
  },

  get foodMultiplier() {
    let m = 1;
    for (const e of this.activeEvents) { if (e.foodMult) m *= e.foodMult; }
    return m;
  },

  get fertilityMultiplier() {
    let m = 1;
    for (const e of this.activeEvents) { if (e.fertMult) m *= e.fertMult; }
    return m;
  },

  get mutationMultiplier() {
    let m = 1;
    for (const e of this.activeEvents) { if (e.mutMult) m *= e.mutMult; }
    return m;
  }
};

// ============================================================
// SIMULATION
// ============================================================
class Simulation {
  constructor(world) {
    this.world = world;
    this.round = 0;
    this.paused = true;
    this.speed = 0; // index into speedLevels
    this.totalBirths = 0;
    this.totalDeaths = 0;
    this.eventLog = [];
    this.popHistory = [];
    this.selectedLurch = null;
    this.selectedCell = null;
    this.godMode = false;
    this.godTool = null;
    this.tickTimer = null;

    // Timeline system — tracks major moments
    this.timeline = [];
    this._lastDominantTrait = null;
    this._lastPopMilestone = 0;
    this._peakPop = 0;
    this._recoveryEnergy = 0; // Burst recovery: spikes on pop crisis, decays over time
    this._emergencyEnergy = 0; // Emergency burst: sub-25 pop, decays slower
  }

  log(msg, type = '') {
    this.eventLog.unshift({ round: this.round, msg, type });
    if (this.eventLog.length > 200) this.eventLog.pop();
  }

  addTimeline(icon, msg, category = 'event') {
    this.timeline.push({ round: this.round, icon, msg, category });
  }

  checkMilestones(alive) {
    const pop = alive.length;
    if (pop === 0) {
      if (this._peakPop > 0) {
        this.addTimeline('💀', `EXTINCTION — all lurches dead (peak was ${this._peakPop})`, 'milestone');
        this.log(`EXTINCTION on day ${this.round}. Peak population was ${this._peakPop}.`, 'event');
        if (!this.paused) { this.togglePause(); ui.update(); }
      }
      return;
    }

    // Track peak population
    if (pop > this._peakPop) this._peakPop = pop;

    // Population milestones (every 500)
    const milestone = Math.floor(pop / 500) * 500;
    if (milestone > 0 && milestone > this._lastPopMilestone) {
      this.addTimeline('📈', `Population reached ${milestone}`, 'milestone');
      this._lastPopMilestone = milestone;
    }
    // Population crash detection
    if (this._lastPopMilestone > milestone + 500 && milestone >= 0) {
      this.addTimeline('📉', `Population crashed to ${pop}`, 'milestone');
      this._lastPopMilestone = milestone;
    }

    // Dominant trait shift
    const counts = {};
    for (const g of GENES) counts[g] = 0;
    for (const l of alive) counts[l.dominantGene]++;
    let topTrait = GENES[0];
    for (const g of GENES) { if (counts[g] > counts[topTrait]) topTrait = g; }
    if (this._lastDominantTrait && topTrait !== this._lastDominantTrait) {
      const pct = (counts[topTrait] / alive.length * 100).toFixed(0);
      this.addTimeline('🧬', `${GENE_SHORT[topTrait]} overtook ${GENE_SHORT[this._lastDominantTrait]} as dominant trait (${pct}%)`, 'trait');
    }
    this._lastDominantTrait = topTrait;
  }

  seedPopulation(preset, count) {
    const rng = this.world.rng;
    const presetData = LURCH_PRESETS[preset];

    if (preset === 'specialists') {
      // Two subpopulations
      const half = Math.floor(count / 2);
      const meansA = { vitality:0.7, speed:0.3, strength:0.8, intelligence:0.3, adaptability:0.3, perception:0.4, size:0.7 };
      const meansB = { vitality:0.4, speed:0.7, strength:0.2, intelligence:0.8, adaptability:0.7, perception:0.7, size:0.3 };
      for (let i = 0; i < half; i++) this.spawnLurch(Genetics.createGenome(meansA, 0.12, rng));
      for (let i = 0; i < count - half; i++) this.spawnLurch(Genetics.createGenome(meansB, 0.12, rng));
    } else {
      for (let i = 0; i < count; i++) {
        this.spawnLurch(Genetics.createGenome(presetData.means, presetData.variance, rng));
      }
    }
  }

  spawnLurch(genome, parentA = null, parentB = null) {
    const rng = this.world.rng;
    // Find empty non-impassable cell
    let x, y, attempts = 0;
    do {
      x = rng.nextInt(this.world.w);
      y = rng.nextInt(this.world.h);
      attempts++;
    } while ((this.world.getLurch(x, y) || this.world.getTerrain(x, y).impassable) && attempts < 500);

    if (attempts >= 500) return null;

    const id = nextLurchId++;
    const lurch = new Lurch(id, x, y, genome, parentA, parentB);
    lurch.birthRound = this.round;
    if (parentA || parentB) {
      lurch.juvenile = true;
      lurch.juvenileTimer = CONFIG.juvenileDuration;
    } else {
      lurch.juvenile = false;
      lurch.juvenileTimer = 0;
      lurch.age = rng.nextInt(10); // small starting age variation
    }

    this.world.lurches.push(lurch);
    this.world.placeLurch(lurch);
    return lurch;
  }

  tick() {
    this.round++;
    const world = this.world;
    const rng = world.rng;

    // --- Environment Update ---
    Events.tick(world, this);
    world.regenFood(Events.foodMultiplier);

    // --- Teaching Phase ---
    const alive = world.lurches.filter(l => l.alive);
    for (const lurch of alive) {
      lurch.warned = false; // Reset warnings
      lurch.taught = 0;    // Reset teaching bonus
      lurch.thinkTank = 0; // Reset think tank bonus
    }
    // Think tank: INT lurches near other INT lurches reinforce each other
    for (const lurch of alive) {
      if (lurch.genome.intelligence < 0.3) continue;
      let intNeighbors = 0;
      for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
        const other = world.getLurch(nx, ny);
        if (other && other.alive && other.genome.intelligence >= 0.3) {
          intNeighbors++;
        }
      }
      if (intNeighbors > 0) {
        // Higher INT lurches benefit more from the think tank (mastery scales with talent)
        const intScale = 0.5 + lurch.genome.intelligence; // 0.8 at INT 0.3, up to 1.5 at INT 1.0
        lurch.thinkTank = Math.min(0.20, intNeighbors * 0.05 * intScale); // stronger for high INT, cap +0.20
      }
    }
    // High-INT lurches boost neighbors — settlement amplification
    for (const lurch of alive) {
      if (lurch.genome.intelligence > 0.5) {
        // Count nearby cooperators for teaching amplification
        let settlementBonus = 0;
        for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
          const ally = world.getLurch(nx, ny);
          if (ally && ally.alive && ally !== lurch) {
            const cs = (ally.genome.intelligence + ally.genome.perception) / 2
                     - (ally.genome.strength + ally.genome.size) / 4;
            if (cs > 0.2) settlementBonus += 0.15; // each cooperator nearby boosts teaching 15%
          }
        }
        const teachPower = (lurch.genome.intelligence - 0.5) * 2.5 * (1 + Math.min(settlementBonus, 0.8)); // cap at 80% settlement boost
        for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
          const other = world.getLurch(nx, ny);
          if (other && other.alive && other !== lurch) {
            other.taught = Math.max(other.taught, teachPower); // take best teacher, don't stack
          }
        }
      }
    }

    // Academy edification: think tank members subtly uplift nearby lurches' INT
    // Gentle cultural effect — living near an academy slowly raises baseline intelligence
    // Capped at 0.45 so edification alone can't make INT dominant — that requires birth in an academy
    for (const lurch of alive) {
      if (lurch.thinkTank <= 0) continue;
      const edifyRange = 2; // smaller radius — you have to be close
      const edifyPower = lurch.thinkTank * 0.006; // ~0.0006 to ~0.0012 per tick
      for (const cell of world.cellsInRadius(lurch.x, lurch.y, edifyRange)) {
        const other = world.getLurch(cell[0], cell[1]);
        if (other && other.alive && other !== lurch && other.genome.intelligence < 0.45) {
          // Only edify lurches already leaning INT — don't convert STR bruisers into bad intellectuals
          const g = other.genome;
          const intRank = [g.vitality, g.speed, g.strength, g.adaptability, g.perception, g.size]
            .filter(v => v > g.intelligence).length;
          if (intRank > 1) continue; // INT must be top or 2nd gene to be edifiable
          const oldInt = other.genome.intelligence;
          // Diminishing returns: harder to push higher
          const diminish = 1 - (oldInt / 0.45);
          other.genome.intelligence = Math.min(0.45, oldInt + edifyPower * diminish);
          if (other.genome.intelligence !== oldInt) {
            other.dominantGene = other.getDominantGene();
          }
        }
      }
    }

    // --- Cooperation Phase (high INT+PER share food, reduce stress, heal nearby) ---
    for (const lurch of alive) {
      const coopScore = (lurch.genome.intelligence + lurch.genome.perception) / 2
                      - (lurch.genome.strength + lurch.genome.size) / 4; // brutes don't cooperate
      if (coopScore < 0.3 || lurch.hunger > 60) continue; // too dumb, too hungry, or too brutish

      // Count nearby cooperator allies for healing
      let nearbyCoops = 0;
      // Share food with hungry adjacent neighbors
      for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
        const other = world.getLurch(nx, ny);
        if (!other || !other.alive) continue;

        // Count fellow cooperators
        const otherCoop = (other.genome.intelligence + other.genome.perception) / 2
                        - (other.genome.strength + other.genome.size) / 4;
        if (otherCoop > 0.2) nearbyCoops++;

        // Food sharing
        if (other.hunger > lurch.hunger + 20) {
          const share = Math.min(8, (other.hunger - lurch.hunger) * 0.2) * coopScore;
          other.hunger = Math.max(0, other.hunger - share);
          lurch.hunger = Math.min(CONFIG.starvationThreshold, lurch.hunger + share * 0.5);
          other.stress = Math.max(0, other.stress - 3);
          lurch.stress = Math.max(0, lurch.stress - 2);
        }
      }

      // Cooperative healing: each nearby cooperator ally restores a bit of HP
      if (nearbyCoops > 0 && lurch.hp < lurch.maxHP) {
        const healAmt = Math.min(nearbyCoops * 1.5, lurch.maxHP * 0.03); // up to 3% maxHP per round
        lurch.hp = Math.min(lurch.maxHP, lurch.hp + healAmt);
      }
    }

    // --- Decision Phase ---
    const decisions = [];

    // First pass: kin warnings from brilliant lurches
    for (const lurch of alive) {
      if (lurch.genome.intelligence >= 0.6) {
        // Check for nearby threats
        for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
          const other = world.getLurch(nx, ny);
          if (other && other.alive && other.genome.strength > lurch.genome.strength * 0.8) {
            // Emit warning to kin in range
            for (const cell of world.cellsInRadius(lurch.x, lurch.y, lurch.perceptionRange)) {
              const kin = world.getLurch(cell[0], cell[1]);
              if (kin && kin !== lurch && kin.alive && lurch.genomeSimilarity(kin) > CONFIG.kinSimilarityThreshold) {
                kin.warned = true;
              }
            }
            break;
          }
        }
      }
    }

    world._popCount = alive.length; // Cache for AI decisions

    // Recovery energy: burst when pop drops below 75, decays 25% per tick
    if (alive.length < 75) {
      const crisis = (75 - alive.length) / 75;
      this._recoveryEnergy = Math.max(this._recoveryEnergy, crisis * crisis * 0.32);
    }
    this._recoveryEnergy *= 0.75; // decay 25% per tick — burst fades over ~10 ticks
    // Emergency energy: second burst at sub-25, decays 10% per tick
    if (alive.length < 25) {
      const emergency = (25 - alive.length) / 25;
      this._emergencyEnergy = Math.max(this._emergencyEnergy, emergency * emergency * 0.32);
    }
    this._emergencyEnergy *= 0.90; // decay 10% per tick — fades over ~25 ticks
    // Cache STR dominance fraction for aggression scaling
    let strCount = 0;
    for (const l of alive) { if (l.dominantGene === 'strength') strCount++; }
    world._strFraction = alive.length > 0 ? strCount / alive.length : 0;

    // Compute population centroid on torus for migration pull
    // Uses circular mean: convert positions to angles, average sin/cos
    if (alive.length > 0 && alive.length < 150) {
      let sinX = 0, cosX = 0, sinY = 0, cosY = 0;
      for (const l of alive) {
        const ax = l.x / world.w * Math.PI * 2;
        const ay = l.y / world.h * Math.PI * 2;
        sinX += Math.sin(ax); cosX += Math.cos(ax);
        sinY += Math.sin(ay); cosY += Math.cos(ay);
      }
      const cx = (Math.atan2(sinX / alive.length, cosX / alive.length) / (Math.PI * 2) * world.w + world.w) % world.w;
      const cy = (Math.atan2(sinY / alive.length, cosY / alive.length) / (Math.PI * 2) * world.h + world.h) % world.h;
      world._popCentroid = { x: Math.round(cx), y: Math.round(cy) };
    } else {
      world._popCentroid = null;
    }

    for (const lurch of alive) {
      const decision = DecisionEngine.decide(lurch, world);
      // Kin warning bias: if warned, bias toward flee/hide
      if (lurch.warned && decision.action !== 'move' && decision.action !== 'hide') {
        if (rng.next() < 0.4) {
          decisions.push({ lurch, decision: { action: 'hide' } });
          continue;
        }
      }
      decisions.push({ lurch, decision });
    }

    // --- Resolution Phase ---

    // Fights first
    for (const { lurch, decision } of decisions) {
      if (decision.action !== 'fight' || !lurch.alive) continue;
      const target = decision.target;
      if (!target || !target.alive) continue;
      // Combat exhaustion: can't fight while recovering from last kill
      if (lurch.combatCooldown > 0) { lurch.lastAction = 'exhausted'; continue; }

      lurch.energy = Math.max(0, lurch.energy - CONFIG.fightEnergyCost);
      lurch.hunger = Math.min(CONFIG.starvationThreshold, lurch.hunger + 12); // combat burns calories

      // Evasion: smart lurches can dodge attacks entirely
      const evasionChance = target.effectiveInt * 0.35 + target.genome.speed * 0.1 + target.genome.perception * 0.1; // up to ~55% (INT+SPD+PER)
      if (rng.next() < evasionChance) {
        target.stress = Math.min(100, target.stress + 5); // close call is stressful
        lurch.stress = Math.min(100, lurch.stress + 8); // wasted energy
        this.log(`#${target.id} evaded attack from #${lurch.id}`, 'combat');
        continue;
      }

      // Pack bonus: nearby brutes amplify attack power
      let packAllies = 0;
      for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
        const ally = world.getLurch(nx, ny);
        if (ally && ally.alive && ally !== target) {
          const aggro = (ally.genome.strength + ally.genome.size) / 2
                      - (ally.genome.intelligence + ally.genome.perception) / 2;
          if (aggro > 0.1) packAllies++;
        }
      }
      const packBonus = 1 + packAllies * 0.2; // each brute ally adds 20% attack
      const attackPower = (lurch.genome.strength * 0.6 + lurch.genome.size * 0.4) * lurch.specPenalty * 30 * (0.5 + rng.next() * 0.5) * packBonus;
      let defensePower = (target.genome.size * 0.5 + target.genome.strength * 0.3 + target.genome.adaptability * 0.2) * 20 + world.getTerrain(target.x, target.y).safety * 3;
      // Solo INT defense: smart lurches fight cleverly even alone (parry, misdirect, use terrain)
      defensePower += target.effectiveInt * 10; // up to +10 defense from pure intelligence
      // Academy defense: INT lurches in think tanks devise defenses (traps, weapons, tactics)
      if (target.thinkTank > 0) {
        defensePower *= 1 + target.thinkTank * 5; // +0.25 to +0.75 defense (1-3 INT neighbors)
      }

      // Cooperative defense: nearby cooperators rally to defend
      let coopAllies = 0;
      for (const [nx, ny] of world.neighbors8(target.x, target.y)) {
        const ally = world.getLurch(nx, ny);
        if (ally && ally.alive && ally !== lurch && ally !== target) {
          const allyCoopScore = (ally.genome.intelligence + ally.genome.perception) / 2
                              - (ally.genome.strength + ally.genome.size) / 4;
          if (allyCoopScore > 0.2) coopAllies++;
        }
      }
      if (coopAllies > 0) {
        // Percentage-based damage reduction: each cooperator ally reduces damage 15%, cap 60%
        const coopShield = Math.min(0.6, coopAllies * 0.15);
        defensePower *= (1 + coopShield);
        Events.addVfx('cooperate', target.x, target.y, 10);
      }

      const net = Math.max(1, attackPower - defensePower);
      target.hp -= net;
      // Counter-strike: beefy defenders fight back
      if (target.genome.strength > 0.4 || target.genome.size > 0.4) {
        const counterPower = (target.genome.strength * 0.3 + target.genome.size * 0.2) * 6;
        lurch.hp -= Math.max(1, Math.round(counterPower * (0.2 + rng.next() * 0.3)));
      }
      lurch.lastAction = `fight #${target.id}`;
      lurch.stress = Math.min(100, lurch.stress + 18);
      target.stress = Math.min(100, target.stress + 20);
      this.log(`#${lurch.id} attacked #${target.id} (${Math.round(net)} dmg)`, 'combat');
      if (target.hp <= 0) {
        // Death escape: smart lurches play dead or find a clever way out
        const escapeChance = target.effectiveInt * 0.5; // up to 50% chance for high INT
        if (escapeChance > 0 && rng.next() < escapeChance) {
          target.hp = 1;
          target.stress = 100; // traumatic experience
          target.energy = Math.max(5, target.energy - 20);
          // Flee to a random adjacent empty cell
          const flee = world.emptyAdjacent(target.x, target.y);
          if (flee) { world.moveLurch(target, flee[0], flee[1]); }
          this.log(`#${target.id} escaped death! (played dead / clever escape)`, 'combat');
          lurch.lastAction = `killed? #${target.id}`;
          // Attacker thinks they won — gets spoils and cooldown
          const spoilsMult = 1 + Math.min(packAllies, 3) * 0.08;
          lurch.hunger = Math.max(0, lurch.hunger - 8 * spoilsMult);
          lurch.energy = Math.min(100, lurch.energy + 5 * spoilsMult);
          lurch.combatCooldown = 3;
          continue;
        }
        Events.addVfx('combat', target.x, target.y, 22);
        target.alive = false;
        target.causeOfDeath = 'combat';
        world.removeLurch(target);
        this.totalDeaths++;
        // Victor spoils — reduced: killing feeds you a bit, not a feast
        const spoilsMult = 1 + Math.min(packAllies, 3) * 0.08;
        lurch.hunger = Math.max(0, lurch.hunger - 8 * spoilsMult);
        lurch.energy = Math.min(100, lurch.energy + 5 * spoilsMult);
        // Combat exhaustion: killer needs 3 rounds to recover
        lurch.combatCooldown = 3;
        this.log(`#${target.id} killed by #${lurch.id} (age ${target.age})`, 'death');
      }
      // Attacker dies from counter-strike wounds
      if (lurch.hp <= 0) {
        lurch.alive = false;
        lurch.causeOfDeath = 'combat';
        world.removeLurch(lurch);
        this.totalDeaths++;
        this.log(`#${lurch.id} died from wounds fighting #${target.id}`, 'death');
      }
    }

    // Movement
    for (const { lurch, decision } of decisions) {
      if (decision.action !== 'move' || !lurch.alive) continue;
      const [dx, dy] = decision.dir || [0, 0];
      if (dx === 0 && dy === 0) { lurch.lastAction = 'idle'; continue; }

      const steps = lurch.moveSpeed;
      let moved = false;
      for (let s = 0; s < steps; s++) {
        const nx = world.wrapX(lurch.x + dx);
        const ny = world.wrapY(lurch.y + dy);
        const t = world.getTerrain(nx, ny);
        if (t.impassable) break;
        if (world.getLurch(nx, ny)) break; // Occupied

        const energyCost = t.moveCost * (1 + lurch.genome.size * 0.5) / (1 + lurch.genome.speed * 0.3);
        lurch.energy = Math.max(0, lurch.energy - energyCost);
        world.moveLurch(lurch, nx, ny);
        moved = true;
      }
      lurch.lastAction = moved ? 'move' : 'blocked';
      lurch.hidden = false;
      lurch.sleeping = false;
    }

    // Eating
    for (const { lurch, decision } of decisions) {
      if (decision.action !== 'eat' || !lurch.alive) continue;
      const food = world.getFood(lurch.x, lurch.y);
      const eatAmount = Math.min(food, 3 + lurch.genome.size * 2);
      world.setFood(lurch.x, lurch.y, food - eatAmount);
      // Smart foraging: small personal INT bonus + teaching community bonus
      const smartForage = lurch.effectiveInt * 0.20; // up to +20% from INT alone
      const quickHands = lurch.genome.speed * 0.1; // up to +10% from SPD (fast foragers)
      const teachBonus = 1 + smartForage + quickHands + lurch.taught * 0.3; // teaching adds up to +30%
      const hungerReduce = eatAmount * (CONFIG.eatHungerReduce / 3) * teachBonus;
      lurch.hunger = Math.max(0, lurch.hunger - hungerReduce);
      lurch.energy = Math.min(100, lurch.energy + eatAmount * 2 * teachBonus);
      lurch.lastAction = 'eat';
      lurch.hidden = false;
      lurch.sleeping = false;
    }

    // Reproduction — compute trait frequencies for frequency-dependent inheritance
    const aliveForRepro = world.lurches.filter(l => l.alive);
    const traitFreq = {};
    for (const g of GENES) traitFreq[g] = 0;
    for (const l of aliveForRepro) traitFreq[l.dominantGene]++;
    const popSize = aliveForRepro.length || 1;
    for (const g of GENES) traitFreq[g] /= popSize;

    const burstMult = Events.mutationMultiplier;
    const effMutRate = CONFIG.mutationRate * burstMult;
    for (const { lurch, decision } of decisions) {
      if (decision.action !== 'reproduce' || !lurch.alive) continue;
      const mate = decision.mate;
      if (!mate || !mate.alive || lurch.juvenile || mate.juvenile) continue;
      if (lurch.reproCooldown > 0 || mate.reproCooldown > 0) { lurch.lastAction = 'repro-cooldown'; continue; }
      if (lurch.energy < CONFIG.reproduceEnergyCost || lurch.hunger > 70) continue;
      if (mate.energy < CONFIG.reproduceEnergyCost * 0.5 || mate.hunger > 70) continue;

      // Fertility window: full fertility until 60% of max age, tapers to zero at 90%
      const fertileEnd = 0.9;
      const taperStart = 0.6;
      const agePctL = lurch.age / lurch.maxAge;
      const agePctM = mate.age / mate.maxAge;
      const fertilityL = agePctL < taperStart ? 1 : agePctL >= fertileEnd ? 0 : 1 - (agePctL - taperStart) / (fertileEnd - taperStart);
      const fertilityM = agePctM < taperStart ? 1 : agePctM >= fertileEnd ? 0 : 1 - (agePctM - taperStart) / (fertileEnd - taperStart);
      if (fertilityL <= 0 || fertilityM <= 0) { lurch.lastAction = 'too-old'; continue; }

      // Check mating range: adjacent normally, extends to 2 at low population
      const mateRange = popSize < 200 ? 2 : 1;
      if (world.chebyshev(lurch.x, lurch.y, mate.x, mate.y) > mateRange) continue;

      // Success chance based on health — VIT no longer directly boosts reproduction
      const healthScore = (lurch.hp / lurch.maxHP + mate.hp / mate.maxHP) / 2;
      let reproChance = healthScore * 0.6 * CONFIG.birthRate * Math.min(fertilityL, fertilityM);

      // Settlement fertility bonus: cooperators near cooperators breed more
      let reproCoops = 0;
      let reproNeighbors = 0;
      for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
        const n = world.getLurch(nx, ny);
        if (n) {
          reproNeighbors++;
          const ncs = (n.genome.intelligence + n.genome.perception) / 2
                    - (n.genome.strength + n.genome.size) / 4;
          if (ncs > 0.2) reproCoops++;
        }
      }
      const parentCoop = (lurch.genome.intelligence + lurch.genome.perception) / 2
                       - (lurch.genome.strength + lurch.genome.size) / 4;
      if (parentCoop > 0.2 && reproCoops >= 2) {
        reproChance *= 1 + Math.min(reproCoops * 0.1, 0.25); // up to +25% fertility in settlements
      }

      // Solo INT fertility: smart lurches plan optimal timing for reproduction
      const parentInt = Math.max(lurch.effectiveInt, mate.effectiveInt);
      reproChance *= 1 + parentInt * 0.25; // up to +25% from pure INT (works solo)

      // Think tank fertility: INT lurches in a think tank breed much more (civilization advantage)
      if (lurch.thinkTank > 0) {
        reproChance *= 1 + lurch.thinkTank * 5; // +0.25 to +0.75 boost (1 to 3 INT neighbors)
      }
      if (mate.thinkTank > 0) {
        reproChance *= 1 + mate.thinkTank * 4; // mate's think tank helps too
      }

      // Local density penalty: crowded areas breed less (cooperators + academies partially exempt)
      if (reproNeighbors >= 4) {
        const crowdPenalty = (reproNeighbors - 3) * 0.12;
        let coopExempt = (parentCoop > 0.2 && reproCoops >= 2) ? 0.5 : 0; // settlements resist crowding
        if (lurch.thinkTank > 0) coopExempt = Math.min(0.85, coopExempt + 0.35); // academies strongly resist crowding penalty
        reproChance *= Math.max(0.1, 1 - crowdPenalty * (1 - coopExempt));
      }

      // Low-population recovery: burst then decay (emergency replaces, doesn't stack)
      const recoveryBurst = Math.max(this._recoveryEnergy, this._emergencyEnergy);
      if (recoveryBurst > 0.001) {
        reproChance *= 1 + recoveryBurst;
      }

      // Event-based fertility boost (e.g., Fertile Season)
      reproChance *= Events.fertilityMultiplier;

      if (rng.next() > reproChance) {
        lurch.lastAction = 'repro-fail';
        continue;
      }

      // Find empty cell near parent
      const cell = world.emptyAdjacent(lurch.x, lurch.y) || world.emptyAdjacent(mate.x, mate.y);
      if (!cell) { lurch.lastAction = 'repro-no-room'; continue; }

      // Create offspring (mutation burst scales variance + macro chance inside reproduce)
      const finalGenome = Genetics.reproduce(lurch, mate, rng, traitFreq, effMutRate, burstMult);

      // INT nurturing: smart parents cultivate intelligence in offspring
      // Moderate base from parent INT, meaningful but not overwhelming academy bonus
      const parentMaxInt = Math.max(lurch.effectiveInt, mate.effectiveInt);
      const parentThinkTank = Math.max(lurch.thinkTank || 0, mate.thinkTank || 0);
      if (parentMaxInt > 0.4) {
        let nurture = (parentMaxInt - 0.4) * 0.15; // up to +0.09 base
        // Academy children get a boost — educated upbringing
        if (parentThinkTank > 0) nurture += parentThinkTank * 0.5; // up to +0.10 more in academy
        finalGenome.intelligence = Math.min(1, finalGenome.intelligence + nurture);
      }

      const child = new Lurch(nextLurchId++, cell[0], cell[1], finalGenome, lurch.id, mate.id);
      child.birthRound = this.round;
      child.juvenile = true;
      child.juvenileTimer = CONFIG.juvenileDuration;
      child.hp = child.maxHP * 0.6;
      child.hunger = 30;
      child.energy = 50;

      world.lurches.push(child);
      world.placeLurch(child);
      lurch.children.push(child.id);
      mate.children.push(child.id);

      lurch.energy -= CONFIG.reproduceEnergyCost;
      mate.energy -= CONFIG.reproduceEnergyCost * 0.5;
      // Set reproduction cooldown: 4-6 rounds (healthy = shorter cooldown)
      let cooldown = Math.round(6 - healthScore * 2);
      // INT family planning: smarter lurches recover faster between births
      const intCooldownBonus = Math.max(lurch.effectiveInt, mate.effectiveInt);
      const ttCooldownBonus = Math.max(lurch.thinkTank || 0, mate.thinkTank || 0);
      cooldown = Math.max(2, Math.round(cooldown * (1 - intCooldownBonus * 0.35 - ttCooldownBonus * 1.5))); // up to 35% from INT + 22% from academy
      // Low-population urgency: breed faster when species is at risk
      if (popSize < 100) cooldown = Math.max(2, Math.round(cooldown * (0.5 + popSize / 200)));
      lurch.reproCooldown = cooldown;
      mate.reproCooldown = Math.round(cooldown * 0.7);
      lurch.lastAction = `reproduce → #${child.id}`;
      this.totalBirths++;
      this.log(`#${lurch.id} × #${mate.id} → offspring #${child.id}`, 'birth');
    }

    // Sleep, Hide, Nothing
    for (const { lurch, decision } of decisions) {
      if (!lurch.alive) continue;
      if (decision.action === 'sleep') {
        lurch.sleeping = true;
        lurch.hidden = false;
        lurch.energy = Math.min(100, lurch.energy + CONFIG.sleepEnergyGain);
        lurch.hp = Math.min(lurch.maxHP, lurch.hp + lurch.maxHP * 0.05);
        lurch.stress = Math.max(0, lurch.stress - 10);
        lurch.lastAction = 'sleep';
      } else if (decision.action === 'hide') {
        lurch.hidden = true;
        lurch.sleeping = false;
        lurch.energy = Math.max(0, lurch.energy - CONFIG.hideEnergyCost);
        lurch.lastAction = 'hide';
      } else if (decision.action === 'nothing') {
        lurch.hidden = false;
        lurch.sleeping = false;
        lurch.lastAction = 'idle';
      }
    }

    // --- Discovery Phase (INT + team → terrain upgrades) ---
    if (this.round % 2 === 0) { // check every 2 rounds
      for (const lurch of alive) {
        if (!lurch.alive || lurch.juvenile) continue;
        if (lurch.genome.intelligence < 0.4) continue;
        if (lurch.hunger > 60 || lurch.energy < 20) continue; // hungry/tired lurches don't innovate

        // Scan neighbors for team skills
        let bestSTR = 0, bestSIZ = 0, bestPCP = 0;
        for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
          const other = world.getLurch(nx, ny);
          if (other && other.alive) {
            bestSTR = Math.max(bestSTR, other.genome.strength);
            bestSIZ = Math.max(bestSIZ, other.genome.size);
            bestPCP = Math.max(bestPCP, other.genome.perception);
          }
        }

        // Need minimum team: at least some STR, SIZE, and PCP nearby
        if (bestSTR < 0.3 || bestSIZ < 0.3 || bestPCP < 0.3) continue;

        // Discovery chance = INT * average team skill * base rate
        const teamScore = (bestSTR + bestSIZ + bestPCP) / 3;
        const discoveryChance = lurch.genome.intelligence * teamScore * 0.02;
        if (rng.next() > discoveryChance) continue;

        // Terrain upgrade paths
        const t = world.getTerrain(lurch.x, lurch.y);
        let upgrade = null;
        if (t === TERRAIN.DESERT || t === TERRAIN.RUINS || t === TERRAIN.SWAMP) {
          // Decide plains or forest based on surroundings
          let forestCount = 0, plainsCount = 0;
          for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
            const nt = world.getTerrain(nx, ny);
            if (nt === TERRAIN.FOREST || nt === TERRAIN.LUSH_FOREST) forestCount++;
            if (nt === TERRAIN.PLAINS || nt === TERRAIN.FERTILE_PLAINS) plainsCount++;
          }
          upgrade = forestCount > plainsCount ? TERRAIN.FOREST : TERRAIN.PLAINS;
        } else if (t === TERRAIN.PLAINS) {
          upgrade = TERRAIN.FERTILE_PLAINS;
        } else if (t === TERRAIN.FOREST) {
          upgrade = TERRAIN.LUSH_FOREST;
        }

        if (upgrade) {
          world.setTerrain(lurch.x, lurch.y, upgrade);
          Events.addVfx('sparkle', lurch.x, lurch.y, 20);
          // Discovery costs energy — this is work
          lurch.energy = Math.max(0, lurch.energy - 15);
          lurch.hunger = Math.min(CONFIG.starvationThreshold, lurch.hunger + 10);
          this.log(`💡 #${lurch.id} discovered ${upgrade.name} at (${lurch.x},${lurch.y})`, 'discovery');
        }
      }
    }

    // --- Status Update ---
    for (const lurch of world.lurches) {
      if (!lurch.alive) continue;

      // Age
      lurch.age++;
      if (lurch.reproCooldown > 0) lurch.reproCooldown--;
      if (lurch.combatCooldown > 0) lurch.combatCooldown--;
      if (lurch.juvenile) {
        lurch.juvenileTimer--;
        if (lurch.juvenileTimer <= 0) lurch.juvenile = false;
      }

      // Hunger — VIT efficiency: healthy bodies burn calories slower
      const metabolism = 1 + lurch.genome.vitality * 0.3 + lurch.genome.size * 0.5 + lurch.genome.strength * 0.3 + lurch.genome.adaptability * 0.6;
      const vitEfficiency = 1 - lurch.genome.vitality * 0.1; // up to 10% slower hunger from VIT
      const intEfficiency = 1 - lurch.effectiveInt * 0.15; // up to 15% slower hunger — smart lurches are efficient
      // Group efficiency: lurches in clusters burn less energy (settled agriculture effect)
      // 2+ neighbors = 10% slower hunger, 4+ = 20% (cap). Models reduced need to forage/travel.
      let groupNeighbors = 0;
      for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
        const n = world.getLurch(nx, ny);
        if (n && n.alive) groupNeighbors++;
      }
      const groupEfficiency = groupNeighbors >= 2 ? 1 - Math.min(groupNeighbors * 0.05, 0.2) : 1;
      lurch.hunger = Math.min(CONFIG.starvationThreshold, lurch.hunger + CONFIG.hungerPerRound * metabolism * 0.5 * vitEfficiency * intEfficiency * groupEfficiency);

      // Energy passive drain
      if (!lurch.sleeping) {
        lurch.energy = Math.max(0, lurch.energy + CONFIG.energyPerRound);
      }

      // Stress
      let stressDelta = -2; // Natural decay
      if (lurch.hunger > 70) stressDelta += 5;
      if (lurch.hp / lurch.maxHP < 0.3) stressDelta += 8;
      // Crowding — cooperators tolerate crowds better (settlement bonus)
      let adjacent = 0;
      let coopNeighbors = 0;
      for (const [nx, ny] of world.neighbors8(lurch.x, lurch.y)) {
        const neighbor = world.getLurch(nx, ny);
        if (neighbor) {
          adjacent++;
          const ncs = (neighbor.genome.intelligence + neighbor.genome.perception) / 2
                    - (neighbor.genome.strength + neighbor.genome.size) / 4;
          if (ncs > 0.2) coopNeighbors++;
        }
      }
      const lurchCoopScore = (lurch.genome.intelligence + lurch.genome.perception) / 2
                           - (lurch.genome.strength + lurch.genome.size) / 4;
      // Cooperators in cooperator-heavy areas feel less crowding stress
      const crowdResist = (lurchCoopScore > 0.2 && coopNeighbors >= 2) ? 0.4 : 0;
      if (adjacent > 3) stressDelta += adjacent * 2 * (1 - crowdResist);
      // Safe terrain relief
      if (world.getTerrain(lurch.x, lurch.y).safety >= 4) stressDelta -= 3;
      // INT stress resistance: smart lurches cope better
      const intResist = 1 - lurch.effectiveInt * 0.2; // up to 20% stress reduction
      if (stressDelta > 0) stressDelta *= intResist;
      lurch.stress = Math.max(0, Math.min(100, lurch.stress + stressDelta));

      // Disease — VIT is primary immune system
      if (lurch.diseased) {
        lurch.hp -= CONFIG.diseaseDamage * (1 - Math.sqrt(lurch.genome.vitality) * 0.6);
        // High VIT fights off disease faster (burns through turns quicker)
        const immuneBoost = 1 + lurch.genome.vitality * 0.5;
        lurch.diseaseTurns -= immuneBoost;
        if (lurch.diseaseTurns <= 0) lurch.diseased = false;
      }

      // VIT passive healing: constitution helps recover from injury/sickness
      if (lurch.hp < lurch.maxHP && !lurch.diseased && lurch.hunger < 60) {
        lurch.hp = Math.min(lurch.maxHP, lurch.hp + lurch.genome.vitality * 2);
      }

      // Terrain bonuses
      const terrain = world.getTerrain(lurch.x, lurch.y);
      if (terrain.shelter) {
        // Lush Forest: shelter provides HP regen and stress relief
        lurch.hp = Math.min(lurch.maxHP, lurch.hp + lurch.maxHP * 0.03);
        lurch.stress = Math.max(0, lurch.stress - 3);
      }
      // Terrain hazards
      if (terrain.drowning && lurch.genome.adaptability < 0.5 && !lurch.hidden) {
        if (rng.next() < CONFIG.drownChance * (1 - Math.sqrt(lurch.genome.adaptability))) {
          lurch.hp -= 20;
          if (lurch.hp <= 0) lurch.causeOfDeath = 'drowning';
        }
      }
      if (terrain === TERRAIN.DESERT) {
        lurch.energy = Math.max(0, lurch.energy - CONFIG.desertEnergyDrain);
      }
      if (terrain.disease && !lurch.diseased && rng.next() < CONFIG.diseaseChance * (1 - Math.sqrt(lurch.genome.vitality) * 0.7)) {
        lurch.diseased = true;
        lurch.diseaseTurns = 10 + rng.nextInt(10);
      }

      // Death checks
      if (lurch.hunger >= CONFIG.starvationThreshold) {
        lurch.hp = 0;
        lurch.causeOfDeath = 'starvation';
      }
      if (lurch.age >= lurch.maxAge) {
        lurch.hp = 0;
        lurch.causeOfDeath = 'old age';
      }
      if (lurch.hp <= 0 && lurch.alive) {
        lurch.alive = false;
        if (!lurch.causeOfDeath) lurch.causeOfDeath = 'disease';
        world.removeLurch(lurch);
        // Drop food as corpse
        world.setFood(lurch.x, lurch.y, world.getFood(lurch.x, lurch.y) + 2 + lurch.genome.size * 3);
        this.totalDeaths++;
        this.log(`#${lurch.id} died (${lurch.causeOfDeath}, age ${lurch.age})`, 'death');
      }

      // Update dominant gene (could shift as mutations accumulate... well it's fixed per lurch but let's keep it accurate)
      if (lurch.alive) lurch.dominantGene = lurch.getDominantGene();
    }

    // Record population & check milestones
    const aliveNow = world.lurches.filter(l => l.alive);
    const pop = aliveNow.length;
    this.popHistory.push(pop);
    if (this.popHistory.length > 500) this.popHistory.shift();
    // Check timeline milestones every 10 rounds to reduce overhead
    if (this.round % 10 === 0) this.checkMilestones(aliveNow);
  }

  start() {
    this.paused = false;
    this.scheduleTickLoop();
  }

  pause() {
    this.paused = true;
    if (this.tickTimer) { clearTimeout(this.tickTimer); this.tickTimer = null; }
  }

  togglePause() {
    if (this.paused) this.start(); else this.pause();
  }

  scheduleTickLoop() {
    if (this.paused) return;
    this.tickTimer = setTimeout(() => {
      this.tick();
      renderer.render();
      ui.update();
      this.scheduleTickLoop();
    }, CONFIG.speedLevels[this.speed]);
  }

  stepOnce() {
    this.tick();
    renderer.render();
    ui.update();
  }

  setSpeed(idx) {
    this.speed = Math.max(0, Math.min(CONFIG.speedLevels.length - 1, idx));
    if (!this.paused) {
      if (this.tickTimer) clearTimeout(this.tickTimer);
      this.scheduleTickLoop();
    }
  }
}

// ============================================================
// RENDERER
// ============================================================
class Renderer {
  constructor(canvas, world) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.world = world;
    this.cellW = 12;
    this.cellH = 18;
    this.scrollX = 0;
    this.scrollY = 0;
    this.font = '14px Menlo, Courier New, Consolas, monospace';
    this.resized = false;
  }

  resize() {
    const container = document.getElementById('grid-container');
    const cw = container.clientWidth;
    const ch = container.clientHeight;

    // Compute cell size to fit as much grid as possible
    this.cellW = Math.max(8, Math.floor(cw / Math.min(this.world.w, 120)));
    this.cellH = Math.max(12, Math.floor(ch / Math.min(this.world.h, 60)));

    // Keep aspect ratio reasonable
    this.cellH = Math.max(this.cellH, Math.floor(this.cellW * 1.4));
    this.cellW = Math.max(this.cellW, Math.floor(this.cellH * 0.6));

    this.canvas.width = cw;
    this.canvas.height = ch;
    this.visibleCols = Math.ceil(cw / this.cellW) + 1;
    this.visibleRows = Math.ceil(ch / this.cellH) + 1;
    this.font = `${Math.floor(this.cellH * 0.78)}px Menlo, Courier New, Consolas, monospace`;
    this.resized = true;
  }

  render() {
    if (!this.resized) this.resize();
    const ctx = this.ctx;
    const w = this.world;
    ctx.fillStyle = '#0a0a14';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    ctx.font = this.font;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';

    const halfCellW = this.cellW / 2;
    const halfCellH = this.cellH / 2;

    for (let row = 0; row < this.visibleRows; row++) {
      for (let col = 0; col < this.visibleCols; col++) {
        const gx = w.wrapX(col + this.scrollX);
        const gy = w.wrapY(row + this.scrollY);
        const px = col * this.cellW;
        const py = row * this.cellH;
        const terrain = w.getTerrain(gx, gy);
        const lurch = w.getLurch(gx, gy);

        // Background
        ctx.fillStyle = terrain.bgColor;
        ctx.fillRect(px, py, this.cellW, this.cellH);

        // Food indicator (subtle brightness)
        const food = w.getFood(gx, gy);
        if (food > 2) {
          ctx.fillStyle = `rgba(80, 120, 60, ${food / CONFIG.foodCap * 0.15})`;
          ctx.fillRect(px, py, this.cellW, this.cellH);
        }

        // Global event overlays (ice age, drought)
        const hasIceAge = Events.activeEvents.some(e => e.vfxType === 'iceage');
        const hasDrought = Events.activeEvents.some(e => e.vfxType === 'drought');
        if (hasIceAge) {
          const flicker = 0.12 + Math.sin(performance.now() / 1500 + gx * 0.3 + gy * 0.5) * 0.05;
          ctx.fillStyle = `rgba(173, 226, 255, ${flicker})`;
          ctx.fillRect(px, py, this.cellW, this.cellH);
          // Frost character ▓ on ~30% of cells, shifting over time
          const frostHash = Math.sin(gx * 127.1 + gy * 311.7 + Math.floor(performance.now() / 4000)) * 43758.5453;
          if ((frostHash - Math.floor(frostHash)) < 0.3) {
            ctx.globalAlpha = 0.25 + Math.sin(performance.now() / 2500 + gx + gy) * 0.1;
            ctx.fillStyle = '#ade2ff';
            ctx.fillText('\u2593', px + halfCellW, py + halfCellH);
            ctx.globalAlpha = 1;
          }
        }
        if (hasDrought) {
          const flicker = 0.06 + Math.sin(performance.now() / 3000 + gx * 0.2 + gy * 0.4) * 0.02;
          ctx.fillStyle = `rgba(200, 150, 50, ${flicker})`;
          ctx.fillRect(px, py, this.cellW, this.cellH);
        }

        if (lurch && lurch.alive) {
          // Draw lurch
          const state = lurch.healthState;
          let color = lurch.color;
          let alpha = 1;

          if (state === 'dim') alpha = 0.5;
          else if (state === 'critical') alpha = (sim.round % 2 === 0) ? 1 : 0.2;
          else if (state === 'sleeping') {
            // Inverse: draw bg-colored @ on light bg
            ctx.fillStyle = 'rgba(60, 60, 80, 0.6)';
            ctx.fillRect(px, py, this.cellW, this.cellH);
            color = '#222233';
            alpha = 1;
          }

          // Disease indicator — black plague: dark pulsing aura with sickly undertone
          if (lurch.diseased) {
            const blinkPhase = Math.sin(performance.now() / 200 + lurch.id * 0.7);
            const severity = Math.min(1, lurch.diseaseTurns / 20); // sicker = darker
            // Black overlay — the plague darkens the lurch
            ctx.fillStyle = `rgba(0, 0, 0, ${0.3 + severity * 0.25 + blinkPhase * 0.1})`;
            ctx.fillRect(px, py, this.cellW, this.cellH);
            // Sickly deep purple/black bleed into neighbors
            if (severity > 0.3) {
              ctx.fillStyle = `rgba(30, 5, 30, ${severity * 0.15})`;
              ctx.fillRect(px - this.cellW, py - this.cellH, this.cellW * 3, this.cellH * 3);
            }
            alpha *= (0.4 + blinkPhase * 0.2 + 0.2); // dimmer — the plague drains life
          }

          // Teaching glow — taught lurches get a subtle warm halo
          if (lurch.taught > 0) {
            const glowAlpha = lurch.taught * 0.2;
            ctx.fillStyle = `rgba(255, 220, 100, ${glowAlpha})`;
            ctx.fillRect(px, py, this.cellW, this.cellH);
          }

          // Academy glow — soft golden aura for academy members
          if (lurch.thinkTank > 0) {
            const pulse = Math.sin(performance.now() / 800 + lurch.x * 0.3 + lurch.y * 0.5) * 0.3 + 0.7;
            const glowStrength = lurch.thinkTank * 3 * pulse; // 0 to ~0.45 intensity
            // Core glow on this cell
            ctx.fillStyle = `rgba(255, 200, 50, ${glowStrength * 0.375})`;
            ctx.fillRect(px, py, this.cellW, this.cellH);
            // Soft bleed into surrounding cells (1-cell radius)
            const bleed = glowStrength * 0.1125;
            if (bleed > 0.02) {
              ctx.fillStyle = `rgba(255, 210, 60, ${bleed})`;
              ctx.fillRect(px - this.cellW, py - this.cellH, this.cellW * 3, this.cellH * 3);
            }
          }

          ctx.globalAlpha = alpha;
          ctx.fillStyle = color;
          ctx.fillText('@', px + halfCellW, py + halfCellH);
          ctx.globalAlpha = 1;

          // Juvenile indicator: smaller
          if (lurch.juvenile) {
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillText('·', px + halfCellW, py + halfCellH - this.cellH * 0.25);
          }

          // Selected highlight
          if (sim.selectedLurch === lurch) {
            ctx.strokeStyle = '#ffff44';
            ctx.lineWidth = 2;
            ctx.strokeRect(px + 1, py + 1, this.cellW - 2, this.cellH - 2);
          }
        } else {
          // Draw terrain char
          ctx.fillStyle = terrain.color;
          ctx.globalAlpha = 0.6;
          ctx.fillText(terrain.char, px + halfCellW, py + halfCellH);
          ctx.globalAlpha = 1;

          // Selected cell highlight (empty terrain)
          if (sim.selectedCell && sim.selectedCell.x === gx && sim.selectedCell.y === gy) {
            ctx.strokeStyle = '#8888bb';
            ctx.lineWidth = 1;
            ctx.strokeRect(px + 1, py + 1, this.cellW - 2, this.cellH - 2);
          }
        }
      }
    }

    // Per-cell VFX overlay pass
    const now = performance.now();
    for (const vfx of Events.vfx) {
      const col = vfx.x - this.scrollX;
      const row = vfx.y - this.scrollY;
      // Handle toroidal wrapping for visible area
      const wCol = ((col % w.w) + w.w) % w.w;
      const wRow = ((row % w.h) + w.h) % w.h;
      if (wCol >= this.visibleCols || wRow >= this.visibleRows) continue;
      const px = wCol * this.cellW;
      const py = wRow * this.cellH;
      const life = vfx.ttl / vfx.maxTtl; // 1.0 → 0.0

      if (vfx.type === 'fire') {
        const flicker = Math.sin(now / 60 + vfx.x * 1.7 + vfx.y * 2.3) * 0.5 + 0.5;
        const rage = Math.sin(now / 40 + vfx.x * 3.1 + vfx.y * 1.9) * 0.5 + 0.5;
        // Raging edge: bright red-orange-yellow, pulsing intensely
        const isFrontier = life > 0.5; // newer fires burn brightest
        const r = isFrontier ? 255 : Math.floor(180 + flicker * 75);
        const g = isFrontier ? Math.floor(80 + rage * 120) : Math.floor(30 + flicker * 40);
        const b = isFrontier ? Math.floor(rage * 20) : 0;
        // Background glow — intense at frontier, dimmer behind
        const glowAlpha = isFrontier ? life * 0.85 * (0.6 + flicker * 0.4) : life * 0.5 * (0.3 + flicker * 0.4);
        ctx.fillStyle = `rgba(${r}, ${Math.floor(g * 0.3)}, 0, ${glowAlpha})`;
        ctx.fillRect(px, py, this.cellW, this.cellH);
        // Fire character: ▓ on frontier (raging), ▒ behind (smoldering)
        const ch = isFrontier ? '\u2593' : '\u2592';
        ctx.globalAlpha = isFrontier ? Math.min(1, life * 1.3) : life * 0.7;
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.fillText(ch, px + halfCellW, py + halfCellH);
        ctx.globalAlpha = 1;
      } else if (vfx.type === 'ash') {
        // Burned wake: ░ (176) in dark gray, long-lasting
        ctx.fillStyle = `rgba(20, 15, 10, ${Math.min(life * 1.5, 0.7)})`;
        ctx.fillRect(px, py, this.cellW, this.cellH);
        ctx.globalAlpha = Math.min(life * 1.2, 0.6);
        ctx.fillStyle = '#444038';
        ctx.fillText('\u2591', px + halfCellW, py + halfCellH);
        ctx.globalAlpha = 1;
      } else if (vfx.type === 'flood') {
        const shimmer = Math.sin(now / 300 + vfx.x + vfx.y * 1.5) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(50, 120, 255, ${life * 0.35 * (0.6 + shimmer * 0.4)})`;
        ctx.fillRect(px, py, this.cellW, this.cellH);
      } else if (vfx.type === 'quake') {
        const pulse = Math.sin(now / 80 + vfx.x * 0.5) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(200, 80, 30, ${life * 0.4 * pulse})`;
        ctx.fillRect(px, py, this.cellW, this.cellH);
      } else if (vfx.type === 'explosion') {
        const pulse = Math.sin(now / 60) * 0.5 + 0.5;
        const r = life > 0.7 ? 255 : Math.floor(255 * life);
        const g = life > 0.7 ? Math.floor(255 * (1 - (life - 0.7) * 3)) : Math.floor(100 * life);
        ctx.fillStyle = `rgba(${r}, ${g}, 0, ${life * 0.6 * (0.5 + pulse * 0.5)})`;
        ctx.fillRect(px, py, this.cellW, this.cellH);
      } else if (vfx.type === 'combat') {
        const pulse = Math.sin(now / 40) * 0.5 + 0.5;
        // Bold red burst — expands slightly on hit then contracts
        const burst = life > 0.7 ? (life - 0.7) / 0.3 : 0;
        const expand = burst * 3;
        ctx.fillStyle = `rgba(255, 30, 10, ${Math.min(1, life * 1.2) * (0.6 + pulse * 0.4)})`;
        ctx.fillRect(px - expand, py - expand, this.cellW + expand * 2, this.cellH + expand * 2);
        // Bright core flash on fresh hits
        if (life > 0.6) {
          ctx.fillStyle = `rgba(255, 200, 60, ${(life - 0.6) * 2})`;
          ctx.fillRect(px, py, this.cellW, this.cellH);
        }
        ctx.globalAlpha = Math.min(1, life * 1.5);
        ctx.fillStyle = '#ff6644';
        ctx.fillText('\u2694', px + halfCellW, py + halfCellH);
        ctx.globalAlpha = 1;
      } else if (vfx.type === 'cooperate') {
        const pulse = Math.sin(now / 60) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(30, 100, 255, ${life * 0.6 * (0.5 + pulse * 0.5)})`;
        ctx.fillRect(px, py, this.cellW, this.cellH);
        ctx.globalAlpha = life * 0.9;
        ctx.fillStyle = '#4488ff';
        ctx.fillText('\u2764', px + halfCellW, py + halfCellH);
        ctx.globalAlpha = 1;
      } else if (vfx.type === 'sparkle') {
        const shimmer = Math.sin(now / 40 + vfx.x * 3 + vfx.y * 5) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(100, 255, 140, ${life * 0.5 * (0.4 + shimmer * 0.6)})`;
        ctx.fillRect(px, py, this.cellW, this.cellH);
        ctx.globalAlpha = life * 0.8;
        ctx.fillStyle = '#88ffaa';
        ctx.fillText('*', px + halfCellW, py + halfCellH);
        ctx.globalAlpha = 1;
      }
    }
  }

  // Convert pixel coords to grid coords
  pixelToGrid(px, py) {
    const col = Math.floor(px / this.cellW);
    const row = Math.floor(py / this.cellH);
    return [this.world.wrapX(col + this.scrollX), this.world.wrapY(row + this.scrollY)];
  }
}

// ============================================================
// UI CONTROLLER
// ============================================================
const ui = {
  init() {
    this.roundEl = document.getElementById('round-num');
    this.popEl = document.getElementById('pop-num');
    this.birthEl = document.getElementById('birth-num');
    this.deathEl = document.getElementById('death-num');
    this.avgAgeEl = document.getElementById('avg-age');
    this.foodPctEl = document.getElementById('food-pct');
    this.speedEl = document.getElementById('speed-display');
    this.pauseBtn = document.getElementById('pause-btn');
    this.logEl = document.getElementById('event-log');
    this.inspectorEl = document.getElementById('inspector-content');
    this.terrainEl = document.getElementById('terrain-content');
    this.sparkCanvas = document.getElementById('sparkline-canvas');
    this.sparkCtx = this.sparkCanvas.getContext('2d');
    this.traitDistEl = document.getElementById('trait-distribution');
    this.activeEventsEl = document.getElementById('active-events');
    this.godPanel = document.getElementById('godmode-panel');

    // Find-top-lurch click handler (delegated)
    this.traitDistEl.addEventListener('click', (e) => {
      const btn = e.target.closest('.gene-find');
      if (!btn) return;
      const gene = btn.dataset.gene;
      const alive = world.lurches.filter(l => l.alive);
      if (alive.length === 0) return;
      let best = alive[0];
      for (const l of alive) {
        if (l.genome[gene] > best.genome[gene]) best = l;
      }
      sim.selectedLurch = best;
      sim.selectedCell = { x: best.x, y: best.y };
      // Scroll renderer to center on this lurch
      renderer.scrollX = best.x - Math.floor(renderer.visibleCols / 2);
      renderer.scrollY = best.y - Math.floor(renderer.visibleRows / 2);
      renderer.render();
      ui.selectCell(best.x, best.y);
    });
  },

  update() {
    const alive = world.lurches.filter(l => l.alive);
    const pop = alive.length;

    this.roundEl.textContent = sim.round;
    this.popEl.textContent = pop;
    this.birthEl.textContent = sim.totalBirths;
    this.deathEl.textContent = sim.totalDeaths;
    this.speedEl.textContent = CONFIG.speedLabels[sim.speed];
    this.pauseBtn.textContent = sim.paused ? '▶ Play' : '⏸ Pause';

    if (pop > 0) {
      const avgAge = Math.round(alive.reduce((s, l) => s + l.age, 0) / pop);
      this.avgAgeEl.textContent = avgAge;
    } else {
      this.avgAgeEl.textContent = '—';
    }

    // Food %
    let totalFood = 0, totalCap = world.w * world.h * CONFIG.foodCap;
    for (let i = 0; i < world.w * world.h; i++) totalFood += world.food[i];
    this.foodPctEl.textContent = Math.round(totalFood / totalCap * 100) + '%';

    // Event log
    const logHTML = sim.eventLog.slice(0, 30).map(e =>
      `<div class="log-entry ${e.type}">[D${e.round}] ${e.msg}</div>`
    ).join('');
    this.logEl.innerHTML = logHTML;

    // Sparkline
    this.drawSparkline();

    // Trait distribution
    this.drawTraitDistribution(alive);

    // Active events
    if (Events.activeEvents.length > 0) {
      this.activeEventsEl.innerHTML = Events.activeEvents.map(e =>
        `<div style="color:#cccc44;font-size:12px;">${e.name} (${e.duration} days)</div>`
      ).join('');
    } else {
      this.activeEventsEl.innerHTML = '<span style="color:#555577">None</span>';
    }

    // Inspector — refresh terrain and lurch panels
    if (sim.selectedLurch) {
      if (sim.selectedLurch.alive) {
        this.updateTerrain(sim.selectedLurch.x, sim.selectedLurch.y);
        this.updateInspector(sim.selectedLurch);
      } else {
        this.inspectorEl.innerHTML = '<span style="color:#555577">Lurch died</span>';
        sim.selectedLurch = null;
      }
    } else if (sim.selectedCell) {
      this.updateTerrain(sim.selectedCell.x, sim.selectedCell.y);
    }

    // Timeline (update every 20 rounds to reduce DOM thrash)
    if (sim.round % 20 === 0 || sim.timeline.length !== this._lastTimelineLen) {
      this._lastTimelineLen = sim.timeline.length;
      const tlEl = document.getElementById('timeline-content');
      if (tlEl && sim.timeline.length > 0) {
        tlEl.innerHTML = sim.timeline.slice().reverse().slice(0, 50).map(t =>
          `<div class="tl-entry ${t.category}"><span class="tl-round">D${t.round}</span><span class="tl-icon">${t.icon}</span><span class="tl-msg">${t.msg}</span></div>`
        ).join('');
      }
    }
  },

  drawSparkline() {
    const c = this.sparkCanvas;
    const ctx = this.sparkCtx;
    c.width = c.clientWidth;
    c.height = 40;
    ctx.clearRect(0, 0, c.width, c.height);

    const data = sim.popHistory;
    if (data.length < 2) return;

    const max = Math.max(...data, 1);
    const step = c.width / (data.length - 1);

    ctx.beginPath();
    ctx.strokeStyle = '#446644';
    ctx.lineWidth = 1.5;
    for (let i = 0; i < data.length; i++) {
      const x = i * step;
      const y = c.height - (data[i] / max) * (c.height - 4) - 2;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Fill
    ctx.lineTo((data.length - 1) * step, c.height);
    ctx.lineTo(0, c.height);
    ctx.closePath();
    ctx.fillStyle = 'rgba(68, 102, 68, 0.2)';
    ctx.fill();

    // Labels
    ctx.fillStyle = '#556655';
    ctx.font = '10px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(data[data.length - 1], 4, 12);
  },

  drawTraitDistribution(alive) {
    if (alive.length === 0) {
      this.traitDistEl.innerHTML = '<span style="color:#555577">No population</span>';
      return;
    }
    const counts = {};
    for (const g of GENES) counts[g] = 0;
    for (const l of alive) counts[l.dominantGene]++;

    let html = '';
    for (const g of GENES) {
      const pct = (counts[g] / alive.length * 100).toFixed(0);
      const w = counts[g] / alive.length * 100;
      html += `<div class="gene-bar">
        <span class="gene-label">${GENE_SHORT[g]}</span>
        <div class="gene-track"><div class="gene-fill" style="width:${w}%;background:${GENE_COLORS[g]}"></div></div>
        <span class="gene-val">${counts[g]}<br>(${pct}%)</span>
        <span class="gene-find" data-gene="${g}" title="Find top ${g} lurch">&#x25B6;</span>
      </div>`;
    }
    this.traitDistEl.innerHTML = html;
  },

  updateInspector(lurch) {
    if (!lurch || !lurch.alive) {
      this.inspectorEl.innerHTML = '<span style="color:#555577">Lurch is dead or deselected</span>';
      sim.selectedLurch = null;
      return;
    }

    let html = `<div style="color:#ccccee;font-size:13px;margin-bottom:6px;">
      <strong style="color:${lurch.color}">@ LURCH #${lurch.id}</strong>
      ${lurch.juvenile ? '<span style="color:#888866;font-size:11px;"> (juvenile)</span>' : ''}
      ${lurch.diseased ? '<span style="color:#aa8800;font-size:11px;"> [DISEASED]</span>' : ''}
    </div>`;

    html += `<div class="stat-row"><span class="stat-label">Age</span><span class="stat-value">${lurch.age} / ${Math.round(lurch.maxAge)}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">HP</span><span class="stat-value">${Math.round(lurch.hp)} / ${Math.round(lurch.maxHP)}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">Hunger</span><span class="stat-value">${Math.round(lurch.hunger)} / ${CONFIG.starvationThreshold}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">Energy</span><span class="stat-value">${Math.round(lurch.energy)}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">Stress</span><span class="stat-value">${Math.round(lurch.stress)}</span></div>`;

    html += '<div style="margin:6px 0 4px;border-top:1px solid #1e1e2e;padding-top:4px;">';
    for (const g of GENES) {
      const v = lurch.genome[g];
      const w = v * 100;
      html += `<div class="gene-bar">
        <span class="gene-label">${GENE_SHORT[g]}</span>
        <div class="gene-track"><div class="gene-fill" style="width:${w}%;background:${GENE_COLORS[g]}"></div></div>
        <span class="gene-val">${v.toFixed(2)}</span>
      </div>`;
    }
    html += '</div>';

    html += `<div class="stat-row"><span class="stat-label">Parents</span><span class="stat-value">${lurch.parentA ? `#${lurch.parentA} × #${lurch.parentB}` : 'Original'}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">Children</span><span class="stat-value">${lurch.children.length > 0 ? lurch.children.slice(-5).map(c => '#'+c).join(', ') : 'None'}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">Action</span><span class="stat-value">${lurch.lastAction}</span></div>`;

    // Intelligence roles
    const roles = [];
    if (lurch.genome.intelligence > 0.5) roles.push('🧠 Teacher');
    if (lurch.taught > 0) roles.push('📖 Learning');
    if (lurch.genome.intelligence > 0.4 && lurch.genome.strength > 0.3) roles.push('💡 Discoverer');
    if (roles.length > 0) {
      html += `<div class="stat-row" style="margin-top:4px;"><span class="stat-label">Roles</span><span class="stat-value">${roles.join(' ')}</span></div>`;
    }

    this.inspectorEl.innerHTML = html;
  },

  updateTerrain(x, y) {
    const t = world.getTerrain(x, y);
    const food = world.getFood(x, y);
    const cap = t.enhanced ? CONFIG.foodCap * 1.5 : CONFIG.foodCap;
    const lurchHere = world.getLurch(x, y);

    let html = `<div style="color:#ccccee;font-size:13px;margin-bottom:6px;">
      <strong style="color:${t.color}">${t.char}</strong> <strong>${t.name}</strong>
      <span style="color:#555577;font-size:11px;">(${x}, ${y})</span>
    </div>`;

    html += `<div class="stat-row"><span class="stat-label">Food</span><span class="stat-value">${food.toFixed(1)} / ${cap}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">Regen</span><span class="stat-value">${t.foodRegen}/day</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">Move Cost</span><span class="stat-value">${t.moveCost}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">Safety</span><span class="stat-value">${t.safety}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">Visibility</span><span class="stat-value">${t.visibility}</span></div>`;

    // Special properties
    const specials = [];
    if (t.drowning) specials.push('<span style="color:#aa6644">Drowning risk</span>');
    if (t.disease) specials.push('<span style="color:#aa6644">Disease risk</span>');
    if (t.shelter) specials.push('<span style="color:#22cc44">Shelter (+HP regen)</span>');
    if (t.enhanced) specials.push('<span style="color:#ccaa33">Enhanced terrain</span>');
    if (t.impassable) specials.push('<span style="color:#aa4444">Impassable</span>');
    if (t === TERRAIN.DESERT) specials.push('<span style="color:#aa6644">Energy drain</span>');
    if (specials.length > 0) {
      html += `<div style="margin-top:4px;font-size:11px;">${specials.join(' · ')}</div>`;
    }

    this.terrainEl.innerHTML = html;
  },

  // Called only on click — updates lurch inspector based on who's on the cell
  selectCell(x, y) {
    this.updateTerrain(x, y);
    const lurchHere = world.getLurch(x, y);
    if (lurchHere && lurchHere.alive) {
      sim.selectedLurch = lurchHere;
      this.updateInspector(lurchHere);
    } else {
      sim.selectedLurch = null;
      this.inspectorEl.innerHTML = '<span style="color:#555577">No Lurch on this cell</span>';
    }
  },

  showGodMode() {
    sim.godMode = true;
    this.godPanel.style.display = 'block';
  },

  hideGodMode() {
    sim.godMode = false;
    // Keep godTool active even when panel closes — user needs to click grid
    this.godPanel.style.display = 'none';
  },

  toggleGodMode() {
    if (sim.godMode) this.hideGodMode(); else this.showGodMode();
  },

  updateGodToolStatus() {
    const el = document.getElementById('god-tool-status');
    const canvas = document.getElementById('grid-canvas');
    if (sim.godTool) {
      const labels = { smite: '⚡ SMITE — click or drag', bless: '✨ BLESS — click or drag', spawn: '🌱 SPAWN — click or drag', food: '🍎 PLACE FOOD — click or drag', wall: '🧱 BUILD WALL — click or drag' };
      el.textContent = (labels[sim.godTool] || sim.godTool) + '  (ESC to cancel)';
      el.style.display = 'block';
      canvas.style.cursor = 'crosshair';
    } else {
      el.style.display = 'none';
      canvas.style.cursor = 'default';
    }
  }
};

// ============================================================
// GLOBALS
// ============================================================
let world, sim, renderer;

// ============================================================
// INPUT HANDLING
// ============================================================
function initInput() {
  document.addEventListener('keydown', (e) => {
    if (document.getElementById('setup-screen').style.display !== 'none') return;
    if (document.activeElement && document.activeElement.tagName === 'INPUT') return;

    switch (e.key) {
      case ' ':
        e.preventDefault();
        sim.togglePause();
        ui.update();
        break;
      case '+': case '=':
        sim.setSpeed(sim.speed + 1);
        ui.update();
        break;
      case '-': case '_':
        sim.setSpeed(sim.speed - 1);
        ui.update();
        break;
      case 'g': case 'G':
        ui.toggleGodMode();
        break;
      case 'Escape':
        ui.hideGodMode();
        sim.godTool = null;
        ui.updateGodToolStatus();
        document.getElementById('help-overlay').classList.remove('visible');
        document.getElementById('confirm-overlay').classList.remove('visible');
        break;
      case '?':
        document.getElementById('help-overlay').classList.toggle('visible');
        break;
      case 'n': case 'N':
        if (sim.paused) { sim.stepOnce(); }
        break;
      case 'f': case 'F':
        // Follow: center on selected lurch
        if (sim.selectedLurch && sim.selectedLurch.alive) {
          renderer.scrollX = sim.selectedLurch.x - Math.floor(renderer.visibleCols / 2);
          renderer.scrollY = sim.selectedLurch.y - Math.floor(renderer.visibleRows / 2);
          renderer.render();
        }
        break;
      case 'ArrowLeft':  renderer.scrollX = world.wrapX(renderer.scrollX - 3); renderer.render(); break;
      case 'ArrowRight': renderer.scrollX = world.wrapX(renderer.scrollX + 3); renderer.render(); break;
      case 'ArrowUp':    renderer.scrollY = world.wrapY(renderer.scrollY - 3); renderer.render(); break;
      case 'ArrowDown':  renderer.scrollY = world.wrapY(renderer.scrollY + 3); renderer.render(); break;
    }

    // God mode hotkeys — work anytime (don't need popover open)
    const godEvents = {
      '1': 'drought', '2': 'flood', '3': 'wildfire', '4': 'earthquake',
      '5': 'iceage', '6': 'meteor', '9': 'fertile',
      '7': 'plague', '8': 'mutationburst',
      'c': 'bottleneck', 'C': 'bottleneck',
      'r': 'rejuvenation', 'R': 'rejuvenation',
    };
    const godTools = {
      'l': 'smite', 'L': 'smite',
      'v': 'bless', 'V': 'bless',
      's': 'spawn', 'S': 'spawn',
      'p': 'food', 'P': 'food',
      'w': 'wall', 'W': 'wall',
    };

    if (godEvents[e.key]) {
      triggerGodEvent(godEvents[e.key]);
      ui.hideGodMode();
    }
    if (godTools[e.key]) {
      sim.godTool = godTools[e.key];
      sim.log(`God tool selected: ${sim.godTool} — click on grid`, 'god');
      ui.hideGodMode();
      ui.updateGodToolStatus();
    }
  });

  // God tool apply function — reused by click and drag
  function applyGodToolAt(gx, gy) {
    switch (sim.godTool) {
      case 'smite': {
        const l = world.getLurch(gx, gy);
        if (l && l.alive) {
          l.hp = 0;
          l.causeOfDeath = 'divine smite';
          l.alive = false;
          world.removeLurch(l);
          sim.totalDeaths++;
        }
        break;
      }
      case 'bless': {
        const l = world.getLurch(gx, gy);
        if (l && l.alive) {
          l.hp = l.maxHP;
          l.hunger = 0;
          l.energy = 100;
          l.stress = 0;
          l.diseased = false;
        }
        break;
      }
      case 'food':
        world.setFood(gx, gy, CONFIG.foodCap);
        break;
      case 'wall':
        world.setTerrain(gx, gy, TERRAIN.WALL);
        const l = world.getLurch(gx, gy);
        if (l && l.alive) {
          l.hp = 0; l.causeOfDeath = 'crushed'; l.alive = false;
          world.removeLurch(l);
          sim.totalDeaths++;
        }
        break;
      case 'spawn': {
        // Don't spawn on top of existing lurch or impassable terrain
        const existing = world.getLurch(gx, gy);
        const terrain = world.getTerrain(gx, gy);
        if (!existing && !terrain.impassable) {
          const presetData = LURCH_PRESETS[sim.lurchPreset] || LURCH_PRESETS.balanced;
          const genome = Genetics.createGenome(presetData.means, presetData.variance, world.rng);
          const id = nextLurchId++;
          const newLurch = new Lurch(id, gx, gy, genome);
          newLurch.birthRound = sim.round;
          newLurch.juvenile = false;
          newLurch.age = world.rng.nextInt(10);
          world.lurches.push(newLurch);
          world.placeLurch(newLurch);
        }
        break;
      }
    }
    const vfxType = sim.godTool === 'spawn' ? 'sparkle' : 'explosion';
    Events.addVfx(vfxType, gx, gy, 15);
  }

  // Click and drag on grid
  const canvas = document.getElementById('grid-canvas');
  let godDragging = false;
  let godLastCell = null;
  let godDragCount = 0;

  canvas.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return; // left button only
    const rect = canvas.getBoundingClientRect();
    const [gx, gy] = renderer.pixelToGrid(e.clientX - rect.left, e.clientY - rect.top);

    if (sim.godTool) {
      godDragging = true;
      godLastCell = `${gx},${gy}`;
      godDragCount = 1;
      applyGodToolAt(gx, gy);
      renderer.render();
      e.preventDefault();
      return;
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!godDragging || !sim.godTool) return;
    const rect = canvas.getBoundingClientRect();
    const [gx, gy] = renderer.pixelToGrid(e.clientX - rect.left, e.clientY - rect.top);
    const cellKey = `${gx},${gy}`;
    if (cellKey !== godLastCell) {
      godLastCell = cellKey;
      godDragCount++;
      applyGodToolAt(gx, gy);
      renderer.render();
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    if (!godDragging) return;
    godDragging = false;
    // Log a summary of what happened
    const toolLabels = { smite: '⚡ SMITE', bless: '✨ BLESS', spawn: '🌱 SPAWN', food: '🍎 FOOD', wall: '🧱 WALL' };
    const label = toolLabels[sim.godTool] || sim.godTool;
    if (godDragCount === 1) {
      const rect = canvas.getBoundingClientRect();
      const [gx, gy] = renderer.pixelToGrid(e.clientX - rect.left, e.clientY - rect.top);
      sim.log(`${label} at (${gx},${gy})`, 'god');
    } else {
      sim.log(`${label} — painted ${godDragCount} cells`, 'god');
    }
    godDragCount = 0;
    godLastCell = null;
    // Tool stays active for more painting — ESC to cancel
    renderer.render();
    ui.update();
  });

  // Normal click for cell/lurch selection (only when no god tool)
  canvas.addEventListener('click', (e) => {
    if (sim.godTool) return; // handled by mousedown/up
    const rect = canvas.getBoundingClientRect();
    const [gx, gy] = renderer.pixelToGrid(e.clientX - rect.left, e.clientY - rect.top);
    sim.selectedCell = { x: gx, y: gy };
    ui.selectCell(gx, gy);
    renderer.render();
  });

  // Severity slider display
  const sevSlider = document.getElementById('god-severity');
  const sevVal = document.getElementById('god-severity-val');
  sevSlider.addEventListener('input', () => { sevVal.textContent = sevSlider.value; });

  // Helper: read severity and set it on Events before triggering
  function triggerGodEvent(eventName) {
    Events._severity = parseInt(sevSlider.value) || 5;
    if (Events[eventName]) {
      Events[eventName](world, sim);
      // Log to timeline
      const displayNames = { bottleneck:'Cull', iceage:'Ice Age', mutationburst:'Mutation Burst' };
      const name = displayNames[eventName] || eventName.charAt(0).toUpperCase() + eventName.slice(1);
      const icons = { drought:'🌵', flood:'🌊', wildfire:'🔥', earthquake:'🌋', meteor:'☄️', iceage:'❄️', fertile:'🌱', plague:'🦠', mutationburst:'🧪', bottleneck:'⚡', rejuvenation:'✨' };
      sim.addTimeline(icons[eventName] || '⚡', `${name} [${Events._severity}]`, 'godmode');
      renderer.render();
      ui.update();
    }
  }

  // God mode buttons — auto-close panel after triggering event
  document.querySelectorAll('.gm-btn[data-event]').forEach(btn => {
    btn.addEventListener('click', () => {
      triggerGodEvent(btn.dataset.event);
      ui.hideGodMode();
    });
  });
  document.querySelectorAll('.gm-btn[data-tool]').forEach(btn => {
    btn.addEventListener('click', () => {
      sim.godTool = btn.dataset.tool;
      sim.log(`God tool selected: ${sim.godTool} — click on grid`, 'god');
      ui.hideGodMode();
      ui.updateGodToolStatus();
    });
  });

  // Topbar buttons
  document.getElementById('pause-btn').addEventListener('click', () => { sim.togglePause(); ui.update(); });
  document.getElementById('speed-up').addEventListener('click', () => { sim.setSpeed(sim.speed + 1); ui.update(); });
  document.getElementById('speed-down').addEventListener('click', () => { sim.setSpeed(sim.speed - 1); ui.update(); });
  document.getElementById('god-btn').addEventListener('click', () => ui.toggleGodMode());

  // Resize
  window.addEventListener('resize', () => {
    renderer.resize();
    renderer.render();
  });
}

// ============================================================
// SETUP & START
// ============================================================
// Birth rate slider display
const brSlider = document.getElementById('birth-rate');
const brVal = document.getElementById('birth-rate-val');
brSlider.addEventListener('input', () => { brVal.textContent = (parseFloat(brSlider.value) / 1.6).toFixed(1) + 'x'; });

document.getElementById('start-btn').addEventListener('click', () => {
  const gridW = parseInt(document.getElementById('grid-w').value) || 80;
  const gridH = parseInt(document.getElementById('grid-h').value) || 40;
  const popCount = parseInt(document.getElementById('pop-count').value) || 40;
  const mutRate = parseFloat(document.getElementById('mutation-rate').value) || 0.05;
  const birthRate = (parseFloat(document.getElementById('birth-rate').value) || 1.0) / 2; // slider 1.0x = internal 0.5
  const seedStr = document.getElementById('rng-seed').value.trim();
  const mapPreset = document.getElementById('map-preset').value;
  const lurchPreset = document.getElementById('lurch-preset').value;

  CONFIG.gridW = gridW;
  CONFIG.gridH = gridH;
  CONFIG.population = popCount;
  CONFIG.mutationRate = mutRate;
  CONFIG.birthRate = birthRate;

  const seed = seedStr ? parseInt(seedStr) || hashString(seedStr) : Math.floor(Math.random() * 2147483647);
  CONFIG._currentSeed = seed;
  CONFIG._currentMapPreset = mapPreset;
  CONFIG._currentLurchPreset = lurchPreset;
  const rng = new SeededRNG(seed);

  // Init world
  world = new World(gridW, gridH, rng);
  generateMap(world, mapPreset, rng);

  // Init simulation
  sim = new Simulation(world);
  sim.lurchPreset = lurchPreset;
  sim.seedPopulation(lurchPreset, popCount);

  // Init renderer
  const canvas = document.getElementById('grid-canvas');
  renderer = new Renderer(canvas, world);
  renderer.resize();
  renderer.render();

  // Init UI
  ui.init();
  ui.update();

  // Init input & help
  initInput();
  initHelp();

  // Title click → back to home (seed save modal)
  const confirmOverlay = document.getElementById('confirm-overlay');
  const seedNameInput = document.getElementById('seed-name-input');
  const saveBtn = document.getElementById('confirm-save');
  document.getElementById('title-btn').addEventListener('click', () => {
    // Show current seed info
    document.getElementById('confirm-seed-display').textContent = `Seed: ${CONFIG._currentSeed} · Map: ${CONFIG._currentMapPreset} · Lurches: ${CONFIG._currentLurchPreset}`;
    seedNameInput.value = '';
    saveBtn.disabled = true;
    confirmOverlay.classList.add('visible');
    setTimeout(() => seedNameInput.focus(), 100);
  });
  seedNameInput.addEventListener('input', () => {
    saveBtn.disabled = !seedNameInput.value.trim();
  });
  seedNameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && seedNameInput.value.trim()) {
      saveBtn.click();
    } else if (e.key === 'Escape') {
      confirmOverlay.classList.remove('visible');
      seedNameInput.blur();
    }
  });
  saveBtn.addEventListener('click', () => {
    const name = seedNameInput.value.trim();
    if (!name) return;
    saveSeed(name, {
      seed: CONFIG._currentSeed,
      mapPreset: CONFIG._currentMapPreset,
      lurchPreset: CONFIG._currentLurchPreset,
      gridW: CONFIG.gridW,
      gridH: CONFIG.gridH,
      population: CONFIG.population,
      mutationRate: CONFIG.mutationRate,
      birthRate: CONFIG.birthRate,
      peakPop: sim._peakPop || 0,
      days: sim.round
    });
    location.reload();
  });
  document.getElementById('confirm-ok').addEventListener('click', () => {
    location.reload();
  });
  document.getElementById('confirm-cancel').addEventListener('click', () => {
    confirmOverlay.classList.remove('visible');
  });
  confirmOverlay.addEventListener('click', (e) => {
    if (e.target === confirmOverlay) confirmOverlay.classList.remove('visible');
  });

  // Hide setup, show game
  document.getElementById('setup-screen').style.display = 'none';

  // Auto-start paused
  sim.log(`World seeded (seed: ${seed}). Population: ${popCount} Lurches.`, 'event');
  sim.log('Press SPACE to begin simulation.', 'event');
  ui.update();
});

// ============================================================
// HELP SYSTEM
// ============================================================
const HELP_CONTENT = {
  overview: `
    <h3>What is Lurches?</h3>
    <p>A genetic simulation sandbox. Seed a world with creatures called <strong style="color:#ccccee">Lurches</strong>, then watch evolution unfold — or intervene as a god.</p>
    <p>The joy is emergence: simple rules produce natural selection, cooperation, warfare, academies, and extinction. Then you throw a meteor at it.</p>
    <h3>How It Works</h3>
    <p>Each day, every Lurch scans its surroundings and decides what to do — eat, move, fight, cooperate, sleep, hide, or reproduce. Their <strong style="color:#4488ff">intelligence</strong> determines how well they decide. Actions resolve simultaneously: fights first, then movement, eating, cooperation, reproduction, and rest.</p>
    <p>Lurches carry 7 heritable genes. Offspring get a blend of both parents plus random mutations. Over time, natural selection shapes the population. The well-adapted thrive. The rest perish.</p>
    <h3>Your Role</h3>
    <p>You're not trying to win. You're cultivating a world and watching consequences. Use <strong style="color:#dd66dd">God Mode</strong> to trigger droughts, meteors, plagues — or bless a favored Lurch. See what survives.</p>
    <h3>Saved Seeds</h3>
    <p>Every world is generated from a seed — a number that produces the same starting terrain and population. When you exit a simulation, you can <strong>name and save</strong> the seed. Saved seeds appear on the setup screen so you can replay memorable worlds. The seed guarantees the same starting conditions; evolution diverges from there.</p>
  `,
  terrain: `
    <h3>Terrain Types</h3>
    <p>The world wraps in all directions (toroidal — no edges). Each cell has a terrain type affecting food, movement, safety, and hazards.</p>
    <table>
      <tr><th>Char</th><th>Terrain</th><th>Food</th><th>Move</th><th>Safety</th><th>Special</th></tr>
      <tr><td style="color:#2255aa">~</td><td>Deep Water</td><td>3</td><td>4</td><td>2</td><td style="color:#aa6644">Drowning risk</td></tr>
      <tr><td style="color:#7a8a5a">.</td><td>Plains</td><td>2</td><td>1</td><td>2</td><td>Exposed — easy to find, be found</td></tr>
      <tr><td style="color:#3a7a3a">#</td><td>Forest</td><td>4</td><td>2</td><td>4</td><td>Good foraging, hard to spot</td></tr>
      <tr><td style="color:#ccaa33">∞</td><td>Fertile Plains</td><td>5</td><td>1</td><td>3</td><td style="color:#ccaa33">Rich farmland — discovery only</td></tr>
      <tr><td style="color:#22cc44">♣</td><td>Lush Forest</td><td>6</td><td>2</td><td>5</td><td style="color:#22cc44">Shelter + HP regen — discovery only</td></tr>
      <tr><td style="color:#8a8a8a">^</td><td>Mountain</td><td>1</td><td>4</td><td>5</td><td>Fortress terrain, scarce food</td></tr>
      <tr><td style="color:#5a7a3a">"</td><td>Swamp</td><td>3</td><td>3</td><td>1</td><td style="color:#aa6644">Disease risk</td></tr>
      <tr><td style="color:#ba8a3a">░</td><td>Desert</td><td>0</td><td>2</td><td>3</td><td style="color:#aa6644">Drains energy</td></tr>
      <tr><td style="color:#4a99aa">≈</td><td>Shallows</td><td>2</td><td>2</td><td>3</td><td>Transition water/land</td></tr>
      <tr><td style="color:#7a5a8a">♠</td><td>Ruins</td><td>0</td><td>1</td><td>2</td><td>No food, low visibility</td></tr>
    </table>
    <h3>Enhanced Terrain &amp; Discovery</h3>
    <p>High-INT Lurches surrounded by a capable team (STR + SIZ + PER neighbors, each ≥ 0.3) can <strong>discover</strong> terrain upgrades. Desert, Ruins, and Swamp upgrade to Plains or Forest. Plains upgrades to <span style="color:#ccaa33">Fertile Plains</span>. Forest upgrades to <span style="color:#22cc44">Lush Forest</span>. Enhanced terrain has 1.5× food cap (15 instead of 10) and higher regen. Discovery costs energy — hungry Lurches don't innovate. Disasters can revert enhanced terrain back to Plains. Green <span style="color:#88ffaa">✦</span> sparkles mark discoveries.</p>
    <h3>Food &amp; Cultivation</h3>
    <p>Each cell regenerates 35% of its terrain's food rate per day, up to a cap of 10 (15 for enhanced terrain). Lurches deplete food by eating — fast foragers (SPD) and smart foragers (INT) extract more from each meal. Overpopulated areas get stripped bare, forcing migration or starvation.</p>
    <p>All Lurches contribute a small food regrowth bonus to nearby cells just by being present — scattered seeds, trampled soil. Cooperator clusters contribute significantly more, creating intentional farming that sustains their communities. Groups of 2+ also burn hunger 10–20% slower, modeling the efficiency of agriculture.</p>
    <h3>Map Presets</h3>
    <p><strong>Random</strong> — procedural terrain. <strong>Pangaea</strong> — one continent. <strong>Eden</strong> — lush and abundant. <strong>The Crucible</strong> — harsh desert, tiny oasis. <strong>Archipelago</strong> — islands. <strong>Ring World</strong> — habitable ring, deadly center. <strong>Waterworld</strong> — mostly ocean.</p>
  `,
  lurches: `
    <h3>What Are Lurches?</h3>
    <p>Creatures rendered as <strong style="color:#ccccee">@</strong> on the grid. Color shows their dominant gene — the one with the highest value.</p>
    <table>
      <tr><th>Color</th><th>Dominant Gene</th></tr>
      <tr><td><span style="color:#44ff44">@</span></td><td>Vitality — constitution, immune system</td></tr>
      <tr><td><span style="color:#44ffff">@</span></td><td>Speed — quick, evasive</td></tr>
      <tr><td><span style="color:#ff4444">@</span></td><td>Strength — aggression, combat power</td></tr>
      <tr><td><span style="color:#4488ff">@</span></td><td>Intelligence — planning, teaching</td></tr>
      <tr><td><span style="color:#ffff44">@</span></td><td>Adaptability — environmental resilience</td></tr>
      <tr><td><span style="color:#cccccc">@</span></td><td>Perception — awareness, detection</td></tr>
      <tr><td><span style="color:#ffffff">@</span></td><td>Size — bulk, hit points</td></tr>
    </table>
    <h3>Visual Indicators</h3>
    <table>
      <tr><th>Symbol</th><th>Meaning</th></tr>
      <tr><td><span style="color:#ff4444">⚔</span></td><td>Kill — a Lurch died in combat</td></tr>
      <tr><td><span style="color:#4488ff">♥</span></td><td>Cooperation — teaching, healing, or academy activity</td></tr>
      <tr><td><span style="color:#88ffaa">✦</span></td><td>Discovery — terrain upgraded by an INT Lurch + team</td></tr>
    </table>
    <table>
      <tr><th>Appearance</th><th>State</th></tr>
      <tr><td><strong>Bright</strong></td><td>Healthy</td></tr>
      <tr><td><strong>Dim</strong></td><td>Hungry or injured</td></tr>
      <tr><td><strong>Blinking</strong></td><td>Critical HP or diseased</td></tr>
      <tr><td><strong>Inverse</strong> (dark on light)</td><td>Sleeping</td></tr>
      <tr><td><strong>Small</strong></td><td>Juvenile (still growing)</td></tr>
      <tr><td><strong style="color:#ffc832">Golden glow</strong></td><td>Academy member</td></tr>
    </table>
    <h3>Fighting &amp; War Bands</h3>
    <p>Lurches with high <span style="color:#ff4444">STR</span> + <span style="color:#ffffff">SIZ</span> and low <span style="color:#4488ff">INT</span> + <span style="color:#cccccc">PER</span> are aggressive — they attack neighbors. Attack power scales with STR and SIZ. Brutes near other brutes form <strong>war bands</strong>: +20% damage per ally. Kills yield modest spoils, but combat is costly — it drains energy and burns hunger. Fighters still need to eat regularly. Red <span style="color:#ff4444">&#x2694;</span> flashes mark kills.</p>
    <p>Defenders can <strong>evade</strong> attacks based on INT + SPD + PER (up to ~55% dodge chance). Beefy defenders (STR or SIZ &gt; 0.4) <strong>counter-strike</strong>, dealing damage back to the attacker. Fighters can die from their own aggression. INT Lurches get a solo defense bonus from pure intelligence, and can <strong>play dead</strong> to survive lethal hits (see Death Escape).</p>
    <h3>Cooperation &amp; Academies</h3>
    <p>Lurches with high <span style="color:#4488ff">INT</span> + <span style="color:#cccccc">PER</span> cooperate instead of fight. When cooperators cluster together, they gain compounding benefits: food cultivation (farming nearby tiles), cooperative defense (up to 60% damage reduction from allies), passive healing, amplified teaching, a small fertility bonus, and reduced crowding stress. Cooperators stay put rather than wander. Blue <span style="color:#4488ff">&#x2764;</span> flashes mark cooperation events.</p>
    <p>When INT Lurches cluster together, they form <strong>academies</strong> — a higher level of cooperation. Academy members lock down, glow golden, farm wide, edify neighbors, and nurture smart offspring. Academies are self-sustaining intellectual enclaves that spread INT through both education and reproduction (see the AI &amp; Behavior tab for details).</p>
    <h3>Grouping &amp; Survival</h3>
    <p>When food is scarce, Lurches seek out companions instead of wandering randomly — smarter Lurches do this sooner. Different survival mechanics activate at different population thresholds:</p>
    <p><strong>Wider awareness</strong> (&lt;150 pop) — scan range extends by up to +4 cells, so scattered Lurches can detect each other across a sparse map.</p>
    <p><strong>Migration pull</strong> (&lt;150 pop) — Lurches drift toward the population center instead of wandering randomly. High <span style="color:#cccccc">PER</span> and <span style="color:#4488ff">INT</span> Lurches feel the pull most strongly (up to 100% bias), while even instinctive Lurches get a 30% drift. This draws survivors together over time.</p>
    <p><strong>Aggression dampening</strong> (&lt;100 pop) — brutes become less aggressive. At 50 pop, aggression is halved. When the species is scarce, even fighters hold back.</p>
    <p><strong>Recovery burst</strong> (&lt;75 pop) — a fertility spike fires when population drops below 75, then rapidly fades back to baseline. A second emergency burst fires below 25 and lingers slightly longer — a last gasp. Mating range extends from 1 to 2 cells under 200 population.</p>
    <p><strong>Agriculture effect</strong> — all Lurches contribute small food regrowth to nearby cells just by being present. Cooperators contribute much more (intentional farming). Lurches in groups of 2+ also burn hunger 10–20% slower — the efficiency of cooperative living. This creates a positive feedback loop: grouping → more food → less wandering → more grouping.</p>
    <p><strong>Group stickiness</strong> — at low population, even non-cooperators stay near their group instead of wandering off. Brutes get a weaker version of cooperative stickiness, keeping the cluster together.</p>
    <p>These mechanics create natural boom-bust-recovery cycles rather than terminal extinction spirals.</p>
    <h3>Life Cycle</h3>
    <p><strong>Bright</strong> = healthy. <strong>Dim</strong> = hungry or injured. <strong>Blinking</strong> = critical or diseased. <strong>Inverse</strong> = sleeping. Lurches die from starvation, combat, old age, disease, drowning, desert exposure, or divine smiting. Fertility tapers after 60% of max age and stops at 90% — elders teach and cooperate but breed less frequently.</p>
  `,
  genetics: `
    <h3>The 7 Genes</h3>
    <p>Each gene ranges from 0.0 to 1.0. Higher is stronger, but every gene has a metabolic cost — specialization comes with tradeoffs.</p>
    <table>
      <tr><th>Gene</th><th>Primary Effect</th><th>Tradeoff</th></tr>
      <tr><td style="color:#44ff44">Vitality</td><td>Disease resistance, passive healing, cold tolerance, efficient metabolism</td><td>Metabolism cost</td></tr>
      <tr><td style="color:#44ffff">Speed</td><td>Movement speed, flee success, fast foraging</td><td>Burns energy faster</td></tr>
      <tr><td style="color:#ff4444">Strength</td><td>Attack damage, fight initiation, counter-strikes</td><td>Higher food needs</td></tr>
      <tr><td style="color:#4488ff">Intelligence</td><td>Decision quality, teaching, discovery, evasion, smart foraging, efficient metabolism</td><td>No direct combat bonus</td></tr>
      <tr><td style="color:#ffff44">Adaptability</td><td>Terrain resistance, disease tolerance</td><td>Highest metabolism cost</td></tr>
      <tr><td style="color:#cccccc">Perception</td><td>Scan range, threat detection, cooperation, evasion, migration pull</td><td>Stress from crowds</td></tr>
      <tr><td style="color:#ffffff">Size</td><td>Max HP, combat advantage, counter-strikes</td><td>Needs most food, easy to spot</td></tr>
    </table>
    <h3>Inheritance</h3>
    <p>Offspring genes are a weighted blend of both parents, plus gaussian mutation (with a 2% chance of a large macro-mutation). Rare traits inherit more faithfully (rarity boost), while dominant traits above 3× their expected share are penalized — a self-correcting mechanism inspired by frequency-dependent selection that prevents any single gene from permanently taking over.</p>
    <h3>Specialization Penalty</h3>
    <p>A Lurch that dumps everything into one gene pays a penalty. The more lopsided the genome, the less effective the dominant trait becomes. Balanced genomes are rewarded — generalists aren't flashy, but they're efficient.</p>
    <h3>Natural Selection</h3>
    <p>Populations converge toward traits that fit their environment. Isolated groups diverge. Catastrophes create bottlenecks. Dominant traits trade places over time. It's evolution in fast-forward.</p>
  `,
  ai: `
    <h3>Decision Making</h3>
    <p>Intelligence doesn't just make Lurches "better" — it changes <em>how they think</em>. There are four behavioral tiers:</p>
    <table>
      <tr><th>Tier</th><th>INT Range</th><th>Behavior</th></tr>
      <tr><td style="color:#aa6644">Instinctive</td><td>0.0 – 0.2</td><td>Reactive. Fight or flee randomly. Seeks companions when hungry. Slight migration pull at low pop.</td></tr>
      <tr><td style="color:#aaaa44">Aware</td><td>0.3 – 0.5</td><td>Moves toward food. Flees threats. Follows teachers. Groups up when food is scarce. Moderate migration pull.</td></tr>
      <tr><td style="color:#44aa88">Strategic</td><td>0.6 – 0.8</td><td>Pathfinds to food-rich areas. Retreats to safe terrain. Evaluates mates. Seeks companions early. Strong migration pull.</td></tr>
      <tr><td style="color:#4488ff">Brilliant</td><td>0.9 – 1.0</td><td>Plans ahead. Avoids disease and desert. Territorial. Seeks optimal mates. Groups at first sign of scarcity. Strongest migration pull.</td></tr>
    </table>
    <h3>Stress</h3>
    <p>Stress degrades effective intelligence — a brilliant Lurch at max stress behaves like an instinctive one. Stress rises from hunger, injury, crowding, and threats. It drops from eating, sleeping, safe terrain, and solitude. Cooperators resist crowding stress.</p>
    <h3>Academy Bond</h3>
    <p>INT Lurches (≥ 0.3) near other INT Lurches reinforce each other — +0.05 effective INT per smart neighbor, scaled by intelligence (up to +0.20). This boosts everything: evasion, foraging efficiency, metabolism, stress resistance, and decision quality. The bonus scales with the Lurch's own INT — a genius benefits more from peers than a novice. It's the INT mirror of war bands — brutes hit harder together, thinkers think better together.</p>
    <h3>Teaching</h3>
    <p>Lurches with INT above 0.5 teach nearby neighbors, boosting food-gathering efficiency up to 30%. Taught Lurches glow gold and are drawn to stay near teachers. In cooperator clusters, teaching is amplified — more cooperators nearby means stronger lessons.</p>
    <h3>Discovery</h3>
    <p>A high-INT Lurch surrounded by a team (STR + SIZ + PER) can upgrade terrain: Desert → Plains/Forest, Plains → <span style="color:#ccaa33">Fertile Plains</span>, Forest → <span style="color:#22cc44">Lush Forest</span>. Enhanced terrain has higher food caps and special bonuses. Discovery costs energy — hungry Lurches don't innovate. Disasters reset enhanced terrain.</p>
    <h3>Academies</h3>
    <p>When INT Lurches cluster together, they form <strong>academies</strong> — visible as a soft golden glow. Academy members enter <strong>lockdown</strong>: they eat, reproduce, and hold position but almost never leave (98% stay chance). They forage within a tight radius when hungry instead of wandering off. Academies have a <strong>size cap of 12</strong> — once too many INT Lurches crowd a single area, stickiness drops sharply and excess members disperse to seed new academies elsewhere. Academy members farm a wider area (3 tiles vs 2), get boosted food production, strongly resist crowding penalties on reproduction, and enjoy significant fertility bonuses.</p>
    <h3>Edification</h3>
    <p>Academy members slowly and permanently uplift the <strong>intelligence gene</strong> of nearby Lurches — a cultural education effect. This only affects Lurches already leaning toward INT (it must be their top or second gene), so academies sharpen the intellectually inclined rather than converting warriors into bad scholars. Edification is capped at 0.45 — it can boost a near-INT Lurch into academy range but can't make INT dominant on its own. That requires being born in an academy.</p>
    <h3>INT Nurturing</h3>
    <p>Smart parents (effective INT > 0.4) give their offspring a direct intelligence boost at birth. In an academy, the boost is even larger — children born near other academy members inherit significantly more INT. This is how academies propagate: edification draws in the willing, and nurturing breeds the next generation of thinkers.</p>
    <h3>Death Escape</h3>
    <p>When an INT Lurch takes a lethal hit, it can <strong>play dead</strong> — surviving at 1 HP with maximum stress. The chance scales with effective INT (up to 50%). The attacker gets their spoils and a cooldown (they think they won), while the INT Lurch flees to an adjacent cell. It's costly — the survivor is critically wounded and stressed — but alive.</p>
    <h3>INT Beacon</h3>
    <p>INT Lurches (≥ 0.3) can sense other INT Lurches from up to 20 tiles away — far beyond normal scan range. They prioritize moving toward established academy clusters over lone thinkers. This long-range beacon works across all intelligence tiers, helping scattered INT Lurches find each other and form academies even on large maps.</p>
    <h3>INT Deterrence</h3>
    <p>Smart Lurches add their intelligence to their perceived power, making STR aggressors less likely to target them. Brutes pick on what looks weak — INT Lurches don't look weak.</p>
    <h3>STR Infighting</h3>
    <p>When STR becomes too dominant (> 25% of the population), aggression scales up among fighters. At 50% STR, aggression is 1.5× normal. Warriors turn on each other when there aren't enough other targets — a natural self-correcting mechanism.</p>
    <h3>Kin Warning</h3>
    <p>Smart Lurches (INT ≥ 0.6) warn nearby relatives of danger. Warned kin are more likely to flee. This creates emergent kin selection — families survive better together.</p>
  `,
  godmode: `
    <h3>God Mode</h3>
    <p>Press <code>G</code> to open. The <strong>Severity slider</strong> (1–10) controls magnitude. 5 is default; 10 is apocalyptic.</p>
    <h3>Environmental Events</h3>
    <table>
      <tr><th>Key</th><th>Event</th><th>Effect</th></tr>
      <tr><td><code>1</code></td><td>Drought</td><td>Slash food regen for N days</td></tr>
      <tr><td><code>2</code></td><td>Flood</td><td>Water tiles expand outward</td></tr>
      <tr><td><code>3</code></td><td>Wildfire</td><td>Forests burn to plains, spreading</td></tr>
      <tr><td><code>4</code></td><td>Earthquake</td><td>Terrain scrambled in a radius</td></tr>
      <tr><td><code>5</code></td><td>Ice Age</td><td>Global food cut, cold damage</td></tr>
      <tr><td><code>6</code></td><td>Meteor</td><td>Instant destruction in blast radius</td></tr>
      <tr><td><code>9</code></td><td>Fertile Season</td><td>Boost food regen + reproduction — helps recover from crashes</td></tr>
    </table>
    <h3>Biological Events</h3>
    <table>
      <tr><th>Key</th><th>Event</th><th>Effect</th></tr>
      <tr><td><code>7</code></td><td>Plague</td><td>Disease spreads from patient zero</td></tr>
      <tr><td><code>8</code></td><td>Mutation Burst</td><td>Mutation rate, variance, and macro-mutation chance all spike — disrupts dominant traits with wild offspring</td></tr>
      <tr><td><code>C</code></td><td>Cull</td><td>Kill 50% randomly</td></tr>
      <tr><td><code>R</code></td><td>Rejuvenation</td><td>Heal and refresh all Lurches</td></tr>
    </table>
    <h3>Direct Tools</h3>
    <p>Select a tool, then click or drag on the grid:</p>
    <p><code>L</code> <strong>Smite</strong> — instant kill. <code>V</code> <strong>Bless</strong> — full heal. <code>S</code> <strong>Spawn</strong> — new Lurch. <code>P</code> <strong>Place Food</strong> — max food. <code>W</code> <strong>Build Wall</strong> — impassable. Press ESC to deselect.</p>
  `,
  controls: `
    <h3>Keyboard</h3>
    <table>
      <tr><th>Key</th><th>Action</th></tr>
      <tr><td><code>Space</code></td><td>Pause / Resume</td></tr>
      <tr><td><code>+ / -</code></td><td>Speed up / slow down (5 levels)</td></tr>
      <tr><td><code>N</code></td><td>Step one day (while paused)</td></tr>
      <tr><td><code>G</code></td><td>Toggle God Mode</td></tr>
      <tr><td><code>?</code></td><td>Toggle this guide</td></tr>
      <tr><td><code>F</code></td><td>Follow selected Lurch</td></tr>
      <tr><td><code>Arrow Keys</code></td><td>Scroll the grid</td></tr>
      <tr><td><code>Escape</code></td><td>Close panels / deselect tool</td></tr>
    </table>
    <h3>Mouse</h3>
    <p><strong>Click</strong> any cell to inspect its terrain — food, safety, movement cost, and special properties. If a Lurch is present, the Lurch Inspector also shows genome, stats, parents, children, and last action. In God Mode, select a tool then <strong>click or drag</strong> across the grid to paint it.</p>
    <h3>Tips</h3>
    <p>Start paused and click around to explore. Press Space to run, then watch the population sparkline and event log. When things get boring — drop a meteor.</p>
  `
};

function initHelp() {
  const overlay = document.getElementById('help-overlay');
  const body = document.getElementById('help-body');
  const tabs = document.querySelectorAll('.help-tab');
  const closeBtn = document.getElementById('help-close');
  const helpBtn = document.getElementById('help-btn');

  function showTab(tabId) {
    tabs.forEach(t => t.classList.toggle('active', t.dataset.tab === tabId));
    body.innerHTML = HELP_CONTENT[tabId] || '';
  }

  tabs.forEach(t => t.addEventListener('click', () => showTab(t.dataset.tab)));
  closeBtn.addEventListener('click', () => overlay.classList.remove('visible'));
  helpBtn.addEventListener('click', () => {
    overlay.classList.toggle('visible');
    if (overlay.classList.contains('visible')) showTab('overview');
  });
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.classList.remove('visible');
  });

  // Show overview by default
  showTab('overview');
}

// ============================================================
// SAVED SEEDS (localStorage)
// ============================================================
function getSavedSeeds() {
  try { return JSON.parse(localStorage.getItem('lurches_seeds') || '[]'); }
  catch { return []; }
}
function saveSeed(name, config) {
  const seeds = getSavedSeeds();
  seeds.unshift({ name, ...config, savedAt: Date.now() });
  if (seeds.length > 20) seeds.length = 20; // cap at 20 saved seeds
  localStorage.setItem('lurches_seeds', JSON.stringify(seeds));
}
function deleteSeed(index) {
  const seeds = getSavedSeeds();
  seeds.splice(index, 1);
  localStorage.setItem('lurches_seeds', JSON.stringify(seeds));
  renderSavedSeeds();
}
function renderSavedSeeds() {
  const seeds = getSavedSeeds();
  const group = document.getElementById('saved-seeds-group');
  const list = document.getElementById('saved-seeds-list');
  if (!group || !list) return;
  if (!seeds.length) { group.style.display = 'none'; return; }
  group.style.display = '';
  list.innerHTML = seeds.map((s, i) => {
    const meta = [s.mapPreset, s.lurchPreset, s.days ? `${s.days}d` : ''].filter(Boolean).join(' · ');
    return `<div class="saved-seed-item" data-idx="${i}"><span class="saved-seed-name">${s.name}</span><span class="saved-seed-meta">${meta}</span><span class="saved-seed-delete" data-del="${i}" title="Delete">✕</span></div>`;
  }).join('');
  // Click to load seed
  list.querySelectorAll('.saved-seed-item').forEach(el => {
    el.addEventListener('click', (e) => {
      if (e.target.classList.contains('saved-seed-delete')) return;
      const s = seeds[parseInt(el.dataset.idx)];
      document.getElementById('rng-seed').value = s.seed;
      document.getElementById('map-preset').value = s.mapPreset || 'random';
      document.getElementById('lurch-preset').value = s.lurchPreset || 'balanced';
      document.getElementById('grid-w').value = s.gridW || 80;
      document.getElementById('grid-h').value = s.gridH || 40;
      document.getElementById('pop-count').value = s.population || 200;
      document.getElementById('mutation-rate').value = s.mutationRate || 0.05;
      if (s.birthRate) {
        const sliderVal = s.birthRate * 2; // internal → slider value
        document.getElementById('birth-rate').value = sliderVal;
        document.getElementById('birth-rate-val').textContent = (sliderVal / 1.6).toFixed(1) + 'x';
      }
    });
  });
  // Delete buttons
  list.querySelectorAll('.saved-seed-delete').forEach(el => {
    el.addEventListener('click', (e) => {
      e.stopPropagation();
      deleteSeed(parseInt(el.dataset.del));
    });
  });
}
// Populate saved seeds on page load
renderSavedSeeds();

function hashString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash + str.charCodeAt(i)) | 0;
  }
  return Math.abs(hash);
}
</script>
<script data-goatcounter="https://lurches.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</body>
</html>
